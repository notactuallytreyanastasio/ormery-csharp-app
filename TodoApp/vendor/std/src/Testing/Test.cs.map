{ "version": 3, "file": "csharp/std/src/Testing/Test.cs", "sources": [ "std/testing/testing.temper.md" ], "sourcesContent": [ "# Temper test framework\n\n## Test instance\n\nWe currently convert assert and check macro calls into method calls on a `Test`\ninstance.\n\n    export class Test {\n\nRecommended default Temper assert is soft, meaning that it records failures for\nreporting but doesn't immediately end test execution on a false value. This lets\nyou check multiple conditions more easily.\n\n      @connected(\u0022Test::assert\u0022)\n      public assert(success: Boolean, message: fn (): String): Void {\n        if (!success) {\n          _passing = false;\n          _messages.add(message());\n        }\n      }\n\nTypical hard asserts that end the test on false condition also are available.\n\n      @connected(\u0022Test::assertHard\u0022)\n      public assertHard(\n        success: Boolean,\n        message: fn (): String,\n      ): Void throws Bubble {\n        assert(success, message);\n        if (!success) {\n          // Attempt to distinguish assert fails from others.\n          // Sadly, they can still orelse an assert failure, so this isn't\n          // flawless.\n          _failedOnAssert = true;\n          bail();\n        }\n      }\n\nHarden and end current test on any pending failure if not previously hardened.\nBackends typically insert calls to this if needed, but you can also call it\nmanually at any desired point in your test.\n\n      public softFailToHard(): Void throws Bubble {\n        if (hasUnhandledFail) {\n          _failedOnAssert = true;\n          bail();\n        }\n      }\n\nProvide a bailing `Bubble` method here that enables backends to customize\nmessage delivery on failure.\n\n      @connected(\u0022Test::bail\u0022)\n      private bail(): Never\u003cVoid\u003e throws Bubble {\n        bubble()\n      }\n\nYou can check the current passing state of the test at any time. A test is\ncurrently passing if all soft checks and hard asserts have been successful.\n\nTODO Does this need to be function call syntax for macro purposes?\n\n      @connected(\u0022Test::passing\u0022)\n      public get passing(): Boolean { _passing }\n\nMessages access is presented as a function because it likely allocates. Also,\nmessages might be automatically constructed in some cases, so it's possibly\nunwise to depend on their exact formatting.\n\n      @connected(\u0022Test::messages\u0022)\n      public messages(): List\u003cString\u003e { _messages.toList() }\n\n### Backend helper methods\n\nAvoid using backend helper methods in user code. Their behavior might be\nunreliable on some backends and/or have high risk of changing in future releases\nof Temper.\n\n      @connected(\u0022Test::failedOnAssert\u0022)\n      public get failedOnAssert(): Boolean { _failedOnAssert }\n\nAdditional helper methods to simplify backend code generation in some contexts.\n\n      public get hasUnhandledFail(): Boolean { !(_failedOnAssert || _passing) }\n\nSimple helper to get multiple messages combined for now. We probably want to do\nfancier things in the future, but this can simplify backends for now.\n\n      public messagesCombined(): String? {\n        if (_messages.isEmpty) {\n          // Unexpected, but most backends can do something with null.\n          null\n        } else {\n          _messages.join(\u0022, \u0022) { it =\u003e it }\n        }\n      }\n\n      private var _failedOnAssert: Boolean = false;\n      private var _passing: Boolean = true;\n      private _messages: ListBuilder\u003cString\u003e = new ListBuilder\u003cString\u003e();\n    }\n\n## Interpreter testing support\n\nNOTICE: Don't directly use anything in this section. It just exists for the\nimplementation of testing within the interpreter.\n\n    export let TestCase = Pair\u003cTestName, TestFun\u003e;\n    export let TestFailureMessage = String;\n    export let TestFun = fn (Test): Void throws Bubble;\n    export let TestName = String;\n    export let TestResult = Pair\u003cTestName, List\u003cTestFailureMessage\u003e\u003e;\n\n    @connected(\u0022::processTestCases\u0022)\n    export let processTestCases(testCases: List\u003cTestCase\u003e): List\u003cTestResult\u003e {\n      testCases.map { (testCase): TestResult =\u003e\n        let { key, value as fun } = testCase;\n        let test = new Test();\n        // Actually call the test.\n        var hadBubble = false;\n        fun(test) orelse do { hadBubble = true };\n        // Now get the messages.\n        let messages = test.messages();\n        let failures: List\u003cTestFailureMessage\u003e = if (test.passing \u0026\u0026 !hadBubble) {\n          []\n        } else if (hadBubble \u0026\u0026 !test.failedOnAssert) {\n          // Despite having 1+ failure messages, we seem to have failed on some\n          // Bubble separate from asserts, so add that on.\n          let allMessages = messages.toListBuilder();\n          allMessages.add(\u0022Bubble\u0022);\n          allMessages.toList()\n        } else {\n          messages\n        };\n        // Package up with test name.\n        new Pair(key, failures)\n      }\n    }\n\n    @connected(\u0022::reportTestResults\u0022)\n    export let reportTestResults(\n      testResults: List\u003cTestResult\u003e,\n      writeLine: fn (String): Void,\n    ): Void {\n      // Write as junit xml for consistency with our other backends.\n      // TODO Inject some call to gather this info in structured form?\n      writeLine(\u0022\u003ctestsuites\u003e\u0022);\n      let total = testResults.length.toString();\n      let fails = testResults.reduceFrom(0) { (fails: Int, testResult): Int =\u003e\n        fails + (if (testResult.value.isEmpty) { 0 } else { 1 })\n      }.toString();\n      let totals = \u0022tests='\u0024{total}' failures='\u0024{fails}'\u0022;\n      // Just lie about time for now since it's required.\n      writeLine(\u0022  \u003ctestsuite name='suite' \u0024{totals} time='0.0'\u003e\u0022);\n      for (var i = 0; i \u003c testResults.length; i += 1) {\n        let testResult = testResults[i];\n        let failureMessages = testResult.value;\n        let name = escapeXml(testResult.key);\n        let basics = \u0022name='\u0024{name}' classname='\u0024{name}' time='0.0'\u0022;\n        if (failureMessages.isEmpty) {\n          writeLine(\u0022    \u003ctestcase \u0024{basics} /\u003e\u0022);\n        } else {\n          writeLine(\u0022    \u003ctestcase \u0024{basics}\u003e\u0022);\n          let message = escapeXml(failureMessages.join(\u0022, \u0022) { it =\u003e it });\n          writeLine(\u0022      \u003cfailure message='\u0024{message}' /\u003e\u0022)\n          writeLine(\u0022    \u003c/testcase\u003e\u0022);\n        }\n      }\n      writeLine(\u0022  \u003c/testsuite\u003e\u0022);\n      writeLine(\u0022\u003c/testsuites\u003e\u0022);\n    }\n\n    @connected(\u0022::runTestCases\u0022)\n    export let runTestCases(testCases: List\u003cTestCase\u003e): String {\n      let report = new StringBuilder();\n      reportTestResults(processTestCases(testCases)) { line =\u003e\n        report.append(line);\n        report.append(\u0022\\n\u0022);\n      }\n      report.toString()\n    }\n\nTODO Is this a better idea than inlining each case? We'd need to generate\n`fn testFunction() { runTest(originalFunctionAsCallback) }` or some such.\n\n    export let runTest(testFun: TestFun): Void throws Bubble {\n      let test = new Test();\n      testFun(test) orelse test.assert(false) { \u0022bubble during test running\u0022 };\n      test.softFailToHard();\n    }\n\nTo produce JUnit XML, it's convenient to be able to escape XML text.\n\nescapeXml takes a string and escapes it so that it has the same meaning as an\nXML text node or attribute value.\n\n    let escapeXml(s: String): String {\n      let sb = new StringBuilder();\n      let end = s.end;\n      var emitted = String.begin;\n      for (var i = String.begin; i \u003c end; i = s.next(i)) {\n        let c = s[i];\n        let esc = when (c) {\n          char'\u0026' -\u003e \u0022\u0026amp;\u0022;\n          char'\u003c' -\u003e \u0022\u0026lt;\u0022;\n          char'\u003e' -\u003e \u0022\u0026gt;\u0022;\n          char\u0022'\u0022 -\u003e \u0022\u0026#39;\u0022;\n          char'\u0022' -\u003e \u0022\u0026#34;\u0022;\n          char'\\n', char'\\r', char'\\t' -\u003e continue;\n          else -\u003e if (c \u003c char' ' || c == 0xFFFE || c == 0xFFFF) {\n            // Illegal chars under XML 1.0, but also possibly trouble, so extra\n            // escape them, in a way people aren't likely to accidentally\n            // unescape.\n            \u0022[0x\u0024{c.toString(16)}]\u0022\n          } else {\n            continue;\n          }\n        }\n        sb.appendBetween(s, emitted, i);\n        sb.append(esc);\n        emitted = s.next(i);\n      }\n      if (emitted == String.begin) {\n        s\n      } else {\n        sb.appendBetween(s, emitted, end);\n        sb.toString()\n      }\n    }\n" ], "names": [ "assert", "success", "message", "t#406", "_passing", "_messages", "assertHard", "_failedOnAssert", "softFailToHard", "messages", "t#264", "messagesCombined", "return", "fn", "it", "t#398" ], "mappings": "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" }