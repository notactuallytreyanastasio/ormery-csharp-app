{ "version": 3, "file": "csharp/std/src/Regex/Codes.cs", "sources": [ "std/regex/regex.temper.md" ], "sourcesContent": [ "# Regex Data Model and Functionality\n\nThe structural data model for regex patterns enables direct construction, and\nthe Temper regex dialect compiles static regex text patterns to these objects.\n\nA focus here is on providing tools people can actually reach for when they need\nto do text processing. The execution should be faster on backends like Python\nthan writing raw code, and the implementation in backends like C should\napproximate what you'd like to have written manually.\n\nDue to inadequate and distinct Unicode handling in backend regex engines, the\ninitial feature set avoids character classes and properties but is still aware\nof code points. Parsing focused on limited sets of delimiters works best for\nnow.\n\nThe core feature set here focuses on both the data model and utility functions,\nsuch as matching regexes against strings.\n\n## Regex Data Model\n\nTemper regex representation is composed hierarchically of `RegexNode` objects.\nAnd perhaps the most fundamental `RegexNode` is the [Sequence](#sequence),\nbecause it enables multiple regex components to be strung together. For example,\n`/hi./` is a sequence of [CodePoints](#codepoints) `/hi/` and dot `/./`, but all\ncomponent types extend the `RegexNode` interface.\n\n```\nexport interface RegexNode {\n```\n\nBefore a regex is used, it must be compiled. This transforms a `RegexNode` tree\ninto a backend-native [Regex](#regex). Some helper functions compile on the fly,\nalthough it is faster to reuse a pre-compiled regex.\n\n```\n  // TODO(tjp, regex): Make this into a macro behind the scenes.\n  // TODO(tjp, regex): `compiled\u003cT\u003e(): Regex\u003cT\u003e`\n  public compiled(): Regex { new Regex(this) }\n```\n\nThe simplest use of a regular expression is if it is found in a string.\nAgain, it is better to compile to a `Regex` in advance than to repeatedly call\nconvenience methods on a `RegexNode`.\n\nTODO Remove convenience methods on RegexNode since we emphasize CompiledRegex\nnow?\n\n```\n  public found(text: String): Boolean { compiled().found(text) }\n```\n\nYou can also return match details. The returned groups map contains an entry for\neach key in the order defined in the regex pattern. If no \u0022full\u0022 group is\ndefined, one is added automatically to capture the full matched text.\n\nIn the future, we intend to support customized match types with fields to match\ncapture groups, statically checked where possible.\n\n```\n  // TODO(tjp, regex): Also macro because reification.\n\n  public find(text: String): Match throws Bubble {\n    compiled().find(text)\n  }\n```\n\nReplace and split functions are also available. Both apply to all matches in\nthe string, replacing all or splitting at all.\n\n```\n  public replace(text: String, format: fn (Match): String): String {\n    compiled().replace(text, format)\n  }\n\n  public split(text: String): List\u003cString\u003e {\n    compiled().split(text)\n  }\n```\n\nThat's it for what you can do with regex patterns in Temper today, but there's\nmuch more to say on what kinds of regexes can be built.\n\n```\n}\n```\n\n## Regex Item Types\n\nA `Regex` is composed of a potential variety of subtypes.\n\n### Groups\n\nMultiple types of groups exist:\n\n- [Capture](#capture) `/(?\u003cname\u003e...)/` to remember match groups for later use.\n- Non-capturing group syntax `/(?:...)/`, which is simply a [Regex](#regex)\n  instance in the data model.\n\n### Capture\n\n`Capture` is a [group](#groups) that remembers the matched text for later\naccess. Temper supports only named matches, with current intended syntax\n`/(?name = ...)/`.\n\n```\nexport class Capture(\n  public let name: String,\n  public /*early*/ let item: RegexNode,\n) extends RegexNode {}\n```\n\n### CodePart\n\nA component of a [CodeSet][#codeset], aka character class, which applies to a\nsubset of regex data types.\n\nHere, \u0022code\u0022 is short for \u0022code point\u0022 although \u0022char\u0022 might work better,\ndepending on expectations.\n\n```\nexport interface CodePart extends RegexNode {}\n```\n\n### CodePoints\n\nOne or more verbatim code points, where the sequence matters if within a\n[Regex](#regex) or not if within a [CodeSet](#codeset). Some escapes in\ntextual regex source, such as `/\\t/`, can be stored as raw code points.\n\nThe `String` here can enable more efficient storage than individual code\npoints, although the source text may require non-capture grouping. For example,\n`/(?:abc)?/` optionally matches the string `\u0022abc\u0022`, whereas `/abc?/` matches\n`\u0022ab\u0022` with an optional `\u0022c\u0022`.\n\n```\nexport class CodePoints(\n  public let value: String,\n) extends CodePart {}\n```\n\n### Specials\n\nA number of special match forms exist. In the data model, these are empty\nclasses.\n\n- `.` - `Dot` In default mode, matches any Unicode code point except newline.\n- `^` - `Begin` in default mode matches zero-length at the beginning of a\n  string.\n- `\u0024` - `End` in default mode matches zero-length at the end of a string.\n- `\\b` - `WordBoundary` matches zero-length at the boundary between word and\n  non-word code points. More sophisticated Unicode compliance is TBD.\n- `\\s` (negated as `\\S`) - `Space` matches any horizontal space code point.\n  Details are TBD.\n- `\\w` (negated as `\\W`) - `Word` matches any word code point. Details are TBD.\n  This is currently defined in terms of old ASCII definitions because those are\n  clear. Perhaps this will stay that way, and Unicode properties like `\\p{L}`\n  will be used for human language needs.\n- `\\X` - `GraphemeCluster` might not be supported, but [here is some discussion\n  of how to implement it](\n  https://github.com/rust-lang/regex/issues/54#issuecomment-661905060).\n\n\u003cdetails\u003e\n\n```\nexport interface Special extends RegexNode {}\nexport let Begin: Special = doPure { (): Special =\u003e class Begin extends Special {}; new Begin() };\nexport let Dot: Special = doPure { (): Special =\u003e class Dot extends Special {}; new Dot() };\nexport let End: Special = doPure { (): Special =\u003e class End extends Special {}; new End() };\n// TODO(tjp, regex): We can't easily support this at present across backends.\n// export let GraphemeCluster = doPure { (): Special =\u003e\n//   class GraphemeCluster extends Special {}; new GraphemeCluster()\n// };\nexport let WordBoundary: Special = doPure { (): Special =\u003e\n  class WordBoundary extends Special {}; new WordBoundary()\n};\n\nexport interface SpecialSet extends CodePart \u0026 Special {}\nexport let Digit: SpecialSet = doPure { (): SpecialSet =\u003e\n  class Digit extends SpecialSet {}; new Digit()\n};\nexport let Space: SpecialSet = doPure { (): SpecialSet =\u003e\n  class Space extends SpecialSet {}; new Space()\n};\nexport let Word: SpecialSet = doPure { (): SpecialSet =\u003e\n  class Word extends SpecialSet {}; new Word()\n};\n```\n\n\u003c/details\u003e\n\n### CodeRange\n\nA code point range matches any code point in its inclusive bounds, such as\n`/[a-c]/`. In source, `-` is included in a code set either by escaping or by\nincluding it as the first or last character. A `CodeRange` is usually contained\ninside a [CodeSet](#codeset), and syntactically always is.\n\n```\nexport class CodeRange(\n  public let min: Int,\n  public let max: Int,\n) extends CodePart {}\n```\n\n### CodeSet\n\nA set of code points, any of which can match, such as `/[abc]/` matching any of\n`\u0022a\u0022`, `\u0022b\u0022`, or `\u0022c\u0022`. Alternatively, a negated set is the inverse of the code\npoints given, such as `/[^abc]/`, matching any code point that's not any of\nthese. This is also often called a character class.\n\nFurther, a subset of [specials](#specials) can also be used in code sets. A\nnegated code set of just a special set often has custom syntax. For example,\nnon-space can be said as either `/[^\\s]/` or `/\\S/`.\n\n```\nexport class CodeSet(\n  public let items: List\u003cCodePart\u003e,\n  public let negated: Boolean = false,\n) extends RegexNode {}\n```\n\n### Or\n\n`Or` matches any one of multiple options, such as `/ab|cd|e*/`.\n\n```\nexport class Or(\n  public /*early*/ let items: List\u003cRegexNode\u003e,\n) extends RegexNode {}\n```\n\n### Repeat\n\n`Repeat` matches from a minimum to a maximum number of repeats of a\nsubregex. This can be represented in regex source in a number of ways:\n\n- `?` matches 0 or 1.\n- `*` matches 0 or more.\n- `+` matches 1 or more.\n- `{m}` matches exactly `m` repetitions.\n- `{m,n}` matches between `m` and `n`. Missing `n` is a max of infinity. For\n  example, `{0,1}` is equivalent to `?`, and `{1,}` is equivalent to `+`.\n\nBy default, repetitions are greedy, matching as many repetitions as possible.\nIn regex source, any of the above can have `?` appended to indicated reluctant\n(aka non-greedy), matching as few repetitions as possible.\n\n```\nexport class Repeat(\n  public /*early*/ let item: RegexNode,\n  public let min: Int,\n  public let max: Int?, // where null means infinite\n  public let reluctant: Boolean = false,\n) extends RegexNode {}\n```\n\nWe also have convenience builders.\n\n```\nexport let entire(item: RegexNode): RegexNode {\n  new Sequence([Begin, item, End])\n}\n\nexport let oneOrMore(item: RegexNode, reluctant: Boolean = false): Repeat {\n  { item, min: 1, max: null, reluctant }\n}\n\nexport let optional(item: RegexNode, reluctant: Boolean = false): Repeat {\n  { item, min: 0, max: 1, reluctant }\n}\n```\n\n### Sequence\n\n`Sequence` strings along multiple other regexes in order.\n\n```\nexport class Sequence(\n  public /*early*/ let items: List\u003cRegexNode\u003e,\n) extends RegexNode {}\n```\n\n## Match Objects\n\nFor detailed match results, call `find` on a regex to get a `Match` object\nincluding a map from `String` keys to `Group` values. The iteration order of the\ngroup map is undefined.\n\nWe might support custom match types in the future with static properties instead\nof string-keyed groups. For example: `regex.find\u003cMyCapture\u003e(\u0022....\u0022)`\n\nTODO And sooner than that, we plan connected types for abstract mapping to\nbackend match objects that might not be maps.\n\n```\nexport class Match(\n  public let full: Group,\n  public let groups: Map\u003cString, Group\u003e,\n) {} // interface ... \u003cT = Map\u003cString, Group\u003e\u003e {\n\nexport class Group(\n  public let name: String,\n  public let value: String,\n  public let begin: StringIndex,\n  public let end: StringIndex,\n) {}\n```\n\n## Compiled Regex Objects\n\nThe compiled form of a regex is mostly opaque, but it can be cached for more\nefficient reuse than working from a source [RegexNode](#regex-data-model).\n\n\u003cdetails\u003e\n\n```\n// Provides a workaround for access to std/regex from extension methods that\n// sometimes get defined in temper-core for some backends. Also useful for\n// reference values for the interpreter.\n// TODO Avoid defining regex support in temper-core.\nclass RegexRefs(\n  public let codePoints: CodePoints = new CodePoints(\u0022\u0022),\n  public let group: Group = {\n    name: \u0022\u0022, value: \u0022\u0022, begin: String.begin, end: String.begin\n  },\n  public let match: Match = {\n    full: group,\n    groups: new Map\u003cString, Group\u003e([new Pair(\u0022\u0022, group)]),\n  },\n  public let orObject: Or = new Or([]),\n) {}\n\nlet regexRefs = doPure { new RegexRefs() };\n```\n\n\u003c/details\u003e\n\nTODO Make Regex a connected type for lighter weight usage?\n\n```\nexport class Regex {\n```\n\nThe source `Regex` data is still available on compiled objects in case it's\nneeded for composition or other purposes.\n\n```\n  public let data: RegexNode;\n\n  public constructor(data: RegexNode) {\n    this.data = data;\n    // TODO Pull formatting out of here into a separate library or module???\n    let formatted = RegexFormatter.regexFormat(data);\n    compiled = RegexFormatter.regexCompileFormatted(data, formatted);\n  }\n```\n\nA compiled regex exposes many of the same capabilities as `RegexNode`, but they\nare more efficient to use repeatedly.\n\n```\n  public found(text: String): Boolean {\n    compiledFound(compiled, text)\n  }\n\n  public find(text: String, begin: StringIndex = String.begin): Match throws Bubble {\n    compiledFind(compiled, text, begin, regexRefs)\n  }\n\n  public replace(text: String, format: fn (Match): String): String {\n    compiledReplace(compiled, text, format, regexRefs)\n  }\n\n  public split(text: String): List\u003cString\u003e {\n    compiledSplit(compiled, text, regexRefs)\n  }\n```\n\nTODO(tjp, regex): Any static checking for stable frontend regex values?\n\n\u003cdetails\u003e\n\n```\n  private let compiled: AnyValue;\n\n  // Extension functions on some backends need the private `compiled` value\n  // passed in directly.\n  @connected(\u0022Regex::compiledFound\u0022)\n  private compiledFound(compiled: AnyValue, text: String): Boolean;\n\n  @connected(\u0022Regex::compiledFind\u0022)\n  private compiledFind(\n    compiled: AnyValue, text: String, begin: StringIndex, regexRefs: RegexRefs\n  ): Match throws Bubble;\n\n  @connected(\u0022Regex::compiledReplace\u0022)\n  private compiledReplace(\n    compiled: AnyValue,\n    text: String,\n    format: fn (Match): String,\n    regexRefs: RegexRefs,\n  ): String;\n\n  @connected(\u0022Regex::compiledSplit\u0022)\n  private compiledSplit(\n    compiled: AnyValue,\n    text: String,\n    regexRefs: RegexRefs,\n  ): List\u003cString\u003e;\n```\n\n\u003c/details\u003e\n\n```\n}\n```\n\n## Private implementation matters?\n\nSome regex logic can be shared across backends. These features aren't directly\nexported to the user, however.\n\nTODO But we do want this exported for pre-compiling where possible in backends.\n\nThe intent is that these support features only get included in compiled Temper\ncode if usage depends on dynamically constructed regexes. If all regex building\nis done as stable values, we hope to generated backend compiled regexes purely\nat Temper compile time.\n\n### RegexFormatter\n\n\u003cdetails\u003e\n\n```\nclass RegexFormatter {\n  private let out: StringBuilder = new StringBuilder();\n\n  @connected(\u0022Regex::compileFormatted\u0022)\n  public static regexCompileFormatted(\n    data: RegexNode, formatted: String\n  ): AnyValue;\n\n  @connected(\u0022Regex::format\u0022)\n  public static regexFormat(data: RegexNode): String {\n    new RegexFormatter().format(data)\n  }\n\n  public format(regex: RegexNode): String {\n    pushRegex(regex)\n    out.toString()\n  }\n\n  private pushRegex(regex: RegexNode): Void {\n    when (regex) {\n      // Aggregate types.\n      is Capture -\u003e pushCapture(regex);\n      is CodePoints -\u003e pushCodePoints(regex, false);\n      is CodeRange -\u003e pushCodeRange(regex);\n      is CodeSet -\u003e pushCodeSet(regex);\n      is Or -\u003e pushOr(regex);\n      is Repeat -\u003e pushRepeat(regex);\n      is Sequence -\u003e pushSequence(regex);\n      // Specials.\n      // Some of these will need to be customized on future backends.\n      Begin -\u003e out.append(\u0022^\u0022);\n      Dot -\u003e out.append(\u0022.\u0022);\n      End -\u003e out.append(\u0022\u0024\u0022);\n      WordBoundary -\u003e out.append(\u0022\\\\b\u0022);\n      // Special sets.\n      Digit -\u003e out.append(\u0022\\\\d\u0022);\n      Space -\u003e out.append(\u0022\\\\s\u0022);\n      Word -\u003e out.append(\u0022\\\\w\u0022);\n      // ...\n    }\n  }\n\n  private pushCapture(capture: Capture): Void {\n    out.append(\u0022(\u0022);\n    // TODO(tjp, regex): Consistent name validation rules for all backends???\n    // TODO(tjp, regex): Validate here or in `Capture` constructor???\n    // TODO(tjp, regex): Validate here or where against reused names???\n    pushCaptureName(out, capture.name);\n    pushRegex(capture.item);\n    out.append(\u0022)\u0022);\n  }\n\n  @connected(\u0022RegexFormatter::pushCaptureName\u0022)\n  private pushCaptureName(out: StringBuilder, name: String): Void {\n    // All so far except Python use this form.\n    out.append(\u0022?\u003c\u0024{name}\u003e\u0022);\n  }\n\n  private pushCode(code: Int, insideCodeSet: Boolean): Void { do {\n    // Goal here is to be pretty where commonly accepted by regex dialects.\n    // Start with pretty escapes to avoid needing numeric escapes.\n    let specialEscape = when (code) {\n      Codes.carriageReturn -\u003e \u0022r\u0022;\n      Codes.newline -\u003e \u0022n\u0022;\n      Codes.tab -\u003e \u0022t\u0022;\n      else -\u003e \u0022\u0022;\n    };\n    if (specialEscape != \u0022\u0022) {\n      out.append(\u0022\\\\\u0022);\n      out.append(specialEscape);\n      return;\n    }\n    // Look up in table for ascii range.\n    if (code \u003c= 0x7F) {\n      let escapeNeed = escapeNeeds[code];\n      if (\n        escapeNeed == needsSimpleEscape ||\n        (insideCodeSet \u0026\u0026 code == Codes.dash)\n      ) {\n        out.append(\u0022\\\\\u0022);\n        out.append(String.fromCodePoint(code));\n        return;\n      } else if (escapeNeed == needsNoEscape) {\n        out.append(String.fromCodePoint(code));\n        return;\n      }\n    }\n    // Not handled, so check additional ranges for plain vs numeric escape.\n    if (\n      code \u003e= Codes.supplementalMin || (\n        code \u003e Codes.highControlMax \u0026\u0026\n        !(\n          (Codes.surrogateMin \u003c= code \u0026\u0026 code \u003c= Codes.surrogateMax) ||\n          code == Codes.uint16Max\n        )\n      )\n    ) {\n      out.append(String.fromCodePoint(code));\n    } else {\n      // No pretty options above, so go numeric. Each backend often varies here.\n      pushCodeTo(out, code, insideCodeSet);\n    }\n  } orelse panic() } // fromCodePoint bubbles\n\n  @connected(\u0022RegexFormatter::pushCodeTo\u0022)\n  private pushCodeTo(out: StringBuilder, code: Int, insideCodeSet: Boolean): Void;\n\n  private pushCodePoints(codePoints: CodePoints, insideCodeSet: Boolean): Void {\n    let value = codePoints.value;\n    for (\n      var index = String.begin;\n      value.hasIndex(index);\n      index = value.next(index)\n    ) {\n      pushCode(value[index], insideCodeSet);\n    }\n  }\n\n  private pushCodeRange(codeRange: CodeRange): Void {\n    out.append(\u0022[\u0022);\n    pushCodeRangeUnwrapped(codeRange);\n    out.append(\u0022]\u0022);\n  }\n\n  private pushCodeRangeUnwrapped(codeRange: CodeRange): Void {\n    pushCode(codeRange.min, true);\n    out.append(\u0022-\u0022);\n    pushCode(codeRange.max, true);\n  }\n\n  private pushCodeSet(codeSet: CodeSet): Void {\n    let adjusted = adjustCodeSet(codeSet, regexRefs);\n    when (adjusted) {\n      is CodeSet -\u003e do {\n        if (adjusted.items.isEmpty) {\n          // Many regex engines don't like empty code sets.\n          if (adjusted.negated) {\n            // Match anything.\n            out.append(raw\u0022[\\s\\S]\u0022);\n          } else {\n            // Match nothing.\n            out.append(\u0022(?:\u0024.)\u0022);\n          }\n        } else {\n          // Common non-empty case.\n          out.append(\u0022[\u0022);\n          if (adjusted.negated) {\n            out.append(\u0022^\u0022);\n          }\n          for (var i = 0; i \u003c adjusted.items.length; i += 1) {\n            pushCodeSetItem(adjusted.items[i]);\n          }\n          out.append(\u0022]\u0022);\n        }\n      }\n      else -\u003e pushRegex(adjusted);\n    }\n  }\n\n  @connected(\u0022RegexFormatter::adjustCodeSet\u0022)\n  private adjustCodeSet(codeSet: CodeSet, regexRefs: RegexRefs): RegexNode { codeSet }\n\n  private pushCodeSetItem(codePart: CodePart): Void {\n    when (codePart) {\n      is CodePoints -\u003e pushCodePoints(codePart, true);\n      is CodeRange -\u003e pushCodeRangeUnwrapped(codePart);\n      is SpecialSet -\u003e pushRegex(codePart);\n    }\n  }\n\n  private pushOr(or: Or): Void {\n    if (!or.items.isEmpty) {\n      out.append(\u0022(?:\u0022);\n      // TODO(tjp, regex): See #822. Until `this` works better, no this in funs.\n      // TODO(tjp, regex): So just manually loop here. Sometimes faster, anyway?\n      pushRegex(or.items[0]);\n      for (var i = 1; i \u003c or.items.length; i += 1) {\n        out.append(\u0022|\u0022);\n        pushRegex(or.items[i]);\n      }\n      out.append(\u0022)\u0022);\n    }\n  }\n\n  private pushRepeat(repeat: Repeat): Void {\n    // Always wrap the main sub-pattern here to make life easy\n    out.append(\u0022(?:\u0022);\n    pushRegex(repeat.item);\n    out.append(\u0022)\u0022);\n    // Then add the repetition part.\n    let min = repeat.min;\n    let max = repeat.max;\n    if (false) {\n    } else if (min == 0 \u0026\u0026 max == 1) {\n      out.append(\u0022?\u0022);\n    } else if (min == 0 \u0026\u0026 max == null) {\n      out.append(\u0022*\u0022);\n    } else if (min == 1 \u0026\u0026 max == null) {\n      out.append(\u0022+\u0022);\n    } else {\n      out.append(\u0022{\u0024{min}\u0022);\n      if (min != max) {\n        out.append(\u0022,\u0022);\n        if (max != null) {\n          out.append(max.toString());\n        }\n      }\n      out.append(\u0022}\u0022);\n    }\n    if (repeat.reluctant) {\n      out.append(\u0022?\u0022);\n    }\n  }\n\n  private pushSequence(sequence: Sequence): Void {\n    // TODO(tjp, regex): Foreach loop/function would be nice.\n    for (var i = 0; i \u003c sequence.items.length; i += 1) {\n      pushRegex(sequence.items[i]);\n    }\n  }\n\n  // Put this here instead of the data model for now because I'm not sure this\n  // makes sense to be part of the public api right now.\n  public maxCode(codePart: CodePart): Int? {\n    when (codePart) {\n      is CodePoints -\u003e do {\n        // Iterating code points is the hardest of the current cases.\n        let value = codePart.value;\n        if (value.isEmpty) {\n          null\n        } else {\n          // My kingdom for a fold, or even just a max, in builtins.\n          var max = 0;\n          for (\n            var index = String.begin;\n            value.hasIndex(index);\n            index = value.next(index)\n          ) {\n            let next = value[index];\n            if (next \u003e max) {\n              max = next;\n            }\n          }\n          max\n        }\n      }\n      // Others below are easy for now.\n      is CodeRange -\u003e codePart.max;\n      Digit -\u003e Codes.digit9;\n      Space -\u003e Codes.space;\n      Word -\u003e Codes.lowerZ;\n      // Actually unexpected, ever, but eh.\n      else -\u003e null;\n    }\n  }\n}\n\n// Cache which chars you just but a blackslash in front of for escaping.\nlet escapeNeeds = doPure { buildEscapeNeeds() };\nlet needsNoEscape = 0;\nlet needsNumericEscape = 1;\nlet needsSimpleEscape = 2;\nlet buildEscapeNeeds(): List\u003cInt\u003e {\n  let escapeNeeds = new ListBuilder\u003cInt\u003e();\n  for (var code = 0; code \u003c= 0x7F; code += 1) {\n    escapeNeeds.add(\n      if (\n        // Dash needs escaping in code sets, but we'll handle that specially.\n        code == Codes.dash ||\n        code == Codes.space ||\n        code == Codes.underscore ||\n        (Codes.digit0 \u003c= code \u0026\u0026 code \u003c= Codes.digit9) ||\n        (Codes.upperA \u003c= code \u0026\u0026 code \u003c= Codes.upperZ) ||\n        (Codes.lowerA \u003c= code \u0026\u0026 code \u003c= Codes.lowerZ)\n      ) {\n        needsNoEscape\n      } else if (\n        // Ampersand and tilde need escaped only in python for now, but meh.\n        // Escaping ampersand breaks JS though.  Fix that in temper-core/regex.js\n        code == Codes.ampersand ||\n        code == Codes.backslash ||\n        code == Codes.caret ||\n        code == Codes.curlyLeft ||\n        code == Codes.curlyRight ||\n        code == Codes.dot ||\n        code == Codes.peso ||\n        code == Codes.pipe ||\n        code == Codes.plus ||\n        code == Codes.question ||\n        code == Codes.roundLeft ||\n        code == Codes.roundRight ||\n        code == Codes.slash ||\n        code == Codes.squareLeft ||\n        code == Codes.squareRight ||\n        code == Codes.star ||\n        code == Codes.tilde\n      ) {\n        needsSimpleEscape\n      } else {\n        // We'll also handle \\r, \\n, and \\t specially.\n        needsNumericEscape\n      },\n    );\n  }\n  escapeNeeds.toList()\n}\n\nclass Codes {\n  public static ampersand: Int = char'\u0026';\n  public static backslash: Int = char'\\\\';\n  public static caret: Int = char'^';\n  public static carriageReturn: Int = char'\\r';\n  public static curlyLeft: Int = char'{';\n  public static curlyRight: Int = char'}';\n  public static dash: Int = char'-';\n  public static dot: Int = char'.';\n  public static highControlMin: Int = 0x7F;\n  public static highControlMax: Int = 0x9F;\n  public static digit0: Int = char'0';\n  public static digit9: Int = char'9';\n  public static lowerA: Int = char'a';\n  public static lowerZ: Int = char'z';\n  public static newline: Int = char'\\n';\n  public static peso: Int = char'\u0024';\n  public static pipe: Int = char'|';\n  public static plus: Int = char'+';\n  public static question: Int = char'?';\n  public static roundLeft: Int = char'(';\n  public static roundRight: Int = char')';\n  public static slash: Int = char'/';\n  public static squareLeft: Int = char'[';\n  public static squareRight: Int = char']';\n  public static star: Int = char'*';\n  public static tab: Int = char'\\t';\n  public static tilde: Int = char'*';\n  public static upperA: Int = char'A';\n  public static upperZ: Int = char'Z';\n  public static space: Int = char' ';\n  public static surrogateMin: Int = 0xD800;\n  public static surrogateMax: Int = 0xDFFF;\n  public static supplementalMin: Int = 0x10000;\n  public static uint16Max: Int = 0xFFFF;\n  public static underscore: Int = char'_';\n}\n\n```\n\n\u003c/details\u003e\n" ], "names": [ "Codes", "ampersand", "backslash", "caret", "carriageReturn", "curlyLeft", "curlyRight", "dash", "dot", "highControlMin", "highControlMax", "digit0", "digit9", "lowerA", "lowerZ", "newline", "peso", "pipe", "plus", "question", "roundLeft", "roundRight", "slash", "squareLeft", "squareRight", "star", "tab", "tilde", "upperA", "upperZ", "space", "surrogateMin", "surrogateMax", "supplementalMin", "uint16Max", "underscore" ], "mappings": "AAsuBM,wBAmCmC,CAAA,AAnCnC;AAmCmC,CAAA;AAnCnC,SAmCmC,AAnCnC,CAAAA;AAmCmC,KAAA;AAlCzB,8BAAwB,AAAb,IAAG,AAAd,CAAAC,SAAS,EAAQ,GAAO;AACxB,8BAAyB,AAAd,IAAG,AAAd,CAAAC,SAAS,EAAQ,GAAQ;AACzB,8BAAoB,AAAb,IAAG,AAAV,CAAAC,KAAK,EAAQ,GAAO;AACpB,8BAA8B,AAAd,IAAG,AAAnB,CAAAC,cAAc,EAAQ,GAAQ;AAC9B,8BAAwB,AAAb,IAAG,AAAd,CAAAC,SAAS,EAAQ,IAAO;AACxB,8BAAyB,AAAb,IAAG,AAAf,CAAAC,UAAU,EAAQ,IAAO;AACzB,8BAAmB,AAAb,IAAG,AAAT,CAAAC,IAAI,EAAQ,GAAO;AACnB,8BAAkB,AAAb,IAAG,AAAR,CAAAC,GAAG,EAAQ,GAAO;AAClB,8BAA0B,AAAV,IAAG,AAAnB,CAAAC,cAAc,EAAQ,IAAI;AAC1B,8BAA0B,AAAV,IAAG,AAAnB,CAAAC,cAAc,EAAQ,IAAI;AAC1B,8BAAqB,AAAb,IAAG,AAAX,CAAAC,MAAM,EAAQ,GAAO;AACrB,8BAAqB,AAAb,IAAG,AAAX,CAAAC,MAAM,EAAQ,GAAO;AACrB,8BAAqB,AAAb,IAAG,AAAX,CAAAC,MAAM,EAAQ,GAAO;AACrB,8BAAqB,AAAb,IAAG,AAAX,CAAAC,MAAM,EAAQ,IAAO;AACrB,8BAAuB,AAAd,IAAG,AAAZ,CAAAC,OAAO,EAAQ,GAAQ;AACvB,8BAAmB,AAAb,IAAG,AAAT,CAAAC,IAAI,EAAQ,GAAO;AACnB,8BAAmB,AAAb,IAAG,AAAT,CAAAC,IAAI,EAAQ,IAAO;AACnB,8BAAmB,AAAb,IAAG,AAAT,CAAAC,IAAI,EAAQ,GAAO;AACnB,8BAAuB,AAAb,IAAG,AAAb,CAAAC,QAAQ,EAAQ,GAAO;AACvB,8BAAwB,AAAb,IAAG,AAAd,CAAAC,SAAS,EAAQ,GAAO;AACxB,8BAAyB,AAAb,IAAG,AAAf,CAAAC,UAAU,EAAQ,GAAO;AACzB,8BAAoB,AAAb,IAAG,AAAV,CAAAC,KAAK,EAAQ,GAAO;AACpB,8BAAyB,AAAb,IAAG,AAAf,CAAAC,UAAU,EAAQ,GAAO;AACzB,8BAA0B,AAAb,IAAG,AAAhB,CAAAC,WAAW,EAAQ,GAAO;AAC1B,8BAAmB,AAAb,IAAG,AAAT,CAAAC,IAAI,EAAQ,GAAO;AACnB,8BAAmB,AAAd,IAAG,AAAR,CAAAC,GAAG,EAAQ,EAAQ;AACnB,8BAAoB,AAAb,IAAG,AAAV,CAAAC,KAAK,EAAQ,GAAO;AACpB,8BAAqB,AAAb,IAAG,AAAX,CAAAC,MAAM,EAAQ,GAAO;AACrB,8BAAqB,AAAb,IAAG,AAAX,CAAAC,MAAM,EAAQ,GAAO;AACrB,8BAAoB,AAAb,IAAG,AAAV,CAAAC,KAAK,EAAQ,GAAO;AACpB,8BAA0B,AAAZ,IAAG,AAAjB,CAAAC,YAAY,EAAQ,MAAM;AAC1B,8BAA0B,AAAZ,IAAG,AAAjB,CAAAC,YAAY,EAAQ,MAAM;AAC1B,8BAA8B,AAAb,IAAG,AAApB,CAAAC,eAAe,EAAQ,MAAO;AAC9B,8BAAuB,AAAZ,IAAG,AAAd,CAAAC,UAAS,EAAQ,MAAM;AACvB,8BAAyB,AAAb,IAAG,AAAf,CAAAC,UAAU,EAAQ,GAAO,CAAA;AAnC7B;AAAA;AAAA;AAAA;AAmC6B" }