{ "version": 3, "file": "csharp/ormery/tests/OrmeryTests.cs", "sources": [ "-work/src/ormery.temper.md" ], "sourcesContent": [ "# ORMery - All-in-One Demo\n\nA simplified version of Ecto in Temper, using secure-composition for\ninjection-proof SQL generation.\n\n    let { sql, SqlFragment, SqlBuilder } = import(\u0022./sql\u0022);\n\n## Field and Schema\n\n    export class Field(\n      public name: String,\n      public fieldType: String,\n      public primaryKey: Boolean,\n      public nullable: Boolean,\n    ) {\n      public get description(): String {\n        let pk = if (primaryKey) { \u0022 (PK)\u0022 } else { \u0022\u0022 };\n        let null = if (nullable) { \u0022 (nullable)\u0022 } else { \u0022\u0022 };\n        \u0022\u0024{name}: \u0024{fieldType}\u0024{pk}\u0024{null}\u0022\n      }\n    }\n\n    export class Schema(\n      public tableName: String,\n      public fields: List\u003cField\u003e,\n    ) {\n      public getField(name: String): Field throws Bubble {\n        for (let field of fields) {\n          if (field.name == name) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public hasField(name: String): Boolean {\n        for (let field of fields) {\n          if (field.name == name) {\n            return true;\n          }\n        }\n        false\n      }\n\n      public get primaryKeyField(): Field throws Bubble {\n        for (let field of fields) {\n          if (field.primaryKey) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public get fieldNames(): List\u003cString\u003e {\n        fields.map { (f: Field): String =\u003e f.name }\n      }\n\n      public describe(): String {\n        let header = \u0022Schema: \u0024{tableName}\\n\u0022;\n        let fieldList = fields\n          .map { (f: Field): String =\u003e \u0022  - \u0024{f.description}\u0022 }\n          .join(\u0022\\n\u0022) { (s: String): String =\u003e s };\n        \u0022\u0024{header}\u0024{fieldList}\u0022\n      }\n    }\n\n    export let field(\n      name: String,\n      fieldType: String,\n      primaryKey: Boolean,\n      nullable: Boolean,\n    ): Field {\n      new Field(name, fieldType, primaryKey, nullable)\n    }\n\n### Identifier validation\n\nOnly allow safe SQL identifier characters: `a-z`, `A-Z`, `0-9`, `_`.\nThis closes the table name backdoor where `schema()` accepted arbitrary\nstrings that passed through `safeSql()` → `appendSafe()` unescaped.\n\n    export let isValidIdentifier(name: String): Boolean {\n      if (name.isEmpty) { return false; }\n      for (let c of name) {\n        if (c != char'_') {\n          if (c \u003e= char'a') {\n            if (c \u003e char'z') { return false; }\n          } else if (c \u003e= char'A') {\n            if (c \u003e char'Z') { return false; }\n          } else if (c \u003e= char'0') {\n            if (c \u003e char'9') { return false; }\n          } else {\n            return false;\n          }\n        }\n      }\n      true\n    }\n\n    export let schema(tableName: String, fields: List\u003cField\u003e): Schema {\n      if (!isValidIdentifier(tableName)) { panic(); }\n      let idField = new Field(\u0022id\u0022, \u0022Int\u0022, true, false);\n      let allFields = new ListBuilder\u003cField\u003e();\n      allFields.add(idField);\n      allFields.addAll(fields);\n      new Schema(tableName, allFields.toList())\n    }\n\n## Record and Store\n\n    export class Record(\n      public data: Map\u003cString, String\u003e,\n    ) {\n      public get(field: String): String throws Bubble {\n        data.get(field)\n      }\n\n      public getOr(field: String, fallback: String): String {\n        data.getOr(field, fallback)\n      }\n\n      public has(field: String): Boolean {\n        data.has(field)\n      }\n\n      public get id(): Int throws Bubble {\n        let idStr = data.get(\u0022id\u0022);\n        idStr.toInt32() orelse bubble()\n      }\n\n      public describe(): String {\n        let pairs = data.toListWith { (k: String, v: String): String =\u003e\n          \u0022\u0024{k}: \u0024{v}\u0022\n        };\n        pairs.join(\u0022, \u0022) { (s: String): String =\u003e s }\n      }\n    }\n\n    export class InMemoryStore() {\n      private var tables: MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e;\n      private var nextIds: MapBuilder\u003cString, Int\u003e;\n\n      public constructor() {\n        tables = new MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e();\n        nextIds = new MapBuilder\u003cString, Int\u003e();\n      }\n\n      private ensureTable(tableName: String): Void {\n        if (!tables.has(tableName)) {\n          tables.set(tableName, new ListBuilder\u003cRecord\u003e());\n          nextIds.set(tableName, 1);\n        }\n      }\n\n      public insert(tableName: String, data: Map\u003cString, String\u003e): Record {\n        ensureTable(tableName);\n        let id = nextIds.getOr(tableName, 1);\n        nextIds.set(tableName, id + 1);\n\n        let dataBuilder = data.toMapBuilder();\n        dataBuilder.set(\u0022id\u0022, id.toString());\n        let record = new Record(dataBuilder.toMap());\n\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.add(record);\n        record\n      }\n\n      public all(tableName: String): List\u003cRecord\u003e {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.toList()\n      }\n\n      public get(tableName: String, id: Int): Record throws Bubble {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n\n        for (let record of table.toList()) {\n          let recordId = record.id orelse bubble();\n          if (recordId == id) {\n            return record;\n          }\n        }\n        bubble()\n      }\n\n      public count(tableName: String): Int {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.length\n      }\n    }\n\n## Query Builder\n\n    export class WhereClause(\n      public field: String,\n      public operator: String,\n      public value: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{operator} \u0024{value}\u0022\n      }\n    }\n\n    export class OrderClause(\n      public field: String,\n      public direction: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{direction}\u0022\n      }\n    }\n\n    export class Query(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var whereClauses: ListBuilder\u003cWhereClause\u003e;\n      private var selectFields: List\u003cString\u003e;\n      private var orderByClauses: ListBuilder\u003cOrderClause\u003e;\n      private var limitValue: Int;\n      private var offsetValue: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        whereClauses = new ListBuilder\u003cWhereClause\u003e();\n        selectFields = [];\n        orderByClauses = new ListBuilder\u003cOrderClause\u003e();\n        limitValue = -1;\n        offsetValue = 0;\n      }\n\n      public where(field: String, operator: String, value: String): Query {\n        whereClauses.add(new WhereClause(field, operator, value));\n        this\n      }\n\n      public select(fields: List\u003cString\u003e): Query {\n        selectFields = fields;\n        this\n      }\n\n      public orderBy(field: String, direction: String): Query {\n        orderByClauses.add(new OrderClause(field, direction));\n        this\n      }\n\n      public limit(n: Int): Query {\n        limitValue = if (n \u003c 0) { 0 } else { n };\n        this\n      }\n\n      public offset(n: Int): Query {\n        offsetValue = n;\n        this\n      }\n\n      private matchesWhere(record: Record): Boolean {\n        for (let clause of whereClauses.toList()) {\n          let recordValue = record.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            return false;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let matches = when (fieldType) {\n            \u0022Int\u0022 -\u003e compareInt(recordValue, clause.operator, clause.value);\n            \u0022String\u0022 -\u003e compareString(recordValue, clause.operator, clause.value);\n            else -\u003e false;\n          };\n          if (!matches) {\n            return false;\n          }\n        }\n        true\n      }\n\n      private projectRecord(record: Record): Record {\n        if (selectFields.length == 0) {\n          return record;\n        }\n        let builder = new MapBuilder\u003cString, String\u003e();\n        for (let fieldName of selectFields) {\n          let value = record.getOr(fieldName, \u0022\u0022);\n          builder.set(fieldName, value);\n        }\n        new Record(builder.toMap())\n      }\n\n      private compareRecords(a: Record, b: Record, orderClauses: List\u003cOrderClause\u003e): Int {\n        for (let clause of orderClauses) {\n          let aVal = a.getOr(clause.field, \u0022\u0022);\n          let bVal = b.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            continue;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let cmp = when (fieldType) {\n            \u0022Int\u0022 -\u003e do {\n              let aInt = aVal.toInt32() orelse 0;\n              let bInt = bVal.toInt32() orelse 0;\n              aInt \u003c=\u003e bInt\n            };\n            \u0022String\u0022 -\u003e aVal \u003c=\u003e bVal;\n            else -\u003e 0;\n          };\n          if (cmp != 0) {\n            return if (clause.direction == \u0022desc\u0022) { -cmp } else { cmp };\n          }\n        }\n        0\n      }\n\n      public all(): List\u003cRecord\u003e {\n        let allRecords = store.all(schema.tableName);\n        let filtered = allRecords.filter { (r: Record): Boolean =\u003e\n          matchesWhere(r)\n        };\n        let sorted = if (orderByClauses.length \u003e 0) {\n          let clauses = orderByClauses.toList();\n          filtered.sorted { (a: Record, b: Record): Int =\u003e\n            compareRecords(a, b, clauses)\n          }\n        } else {\n          filtered\n        };\n        let sliced = if (limitValue \u003e= 0) {\n          let start = offsetValue;\n          let end = offsetValue + limitValue;\n          sorted.slice(start, end)\n        } else if (offsetValue \u003e 0) {\n          sorted.slice(offsetValue, sorted.length)\n        } else {\n          sorted\n        };\n        sliced.map { (r: Record): Record =\u003e projectRecord(r) }\n      }\n\n      public toSql(): SqlFragment {\n        toSqlQuery(schema, selectFields, whereClauses.toList(),\n                   orderByClauses.toList(), limitValue, offsetValue)\n      }\n    }\n\n    let compareInt(recordValue: String, operator: String, clauseValue: String): Boolean {\n      let rv = recordValue.toInt32() orelse 0;\n      let cv = clauseValue.toInt32() orelse 0;\n      if (clauseValue != cv.toString()) { return false; }\n      when (operator) {\n        \u0022==\u0022 -\u003e rv == cv;\n        \u0022!=\u0022 -\u003e rv != cv;\n        \u0022\u003e\u0022 -\u003e rv \u003e cv;\n        \u0022\u003c\u0022 -\u003e rv \u003c cv;\n        \u0022\u003e=\u0022 -\u003e rv \u003e= cv;\n        \u0022\u003c=\u0022 -\u003e rv \u003c= cv;\n        else -\u003e false;\n      }\n    }\n\n    let compareString(recordValue: String, operator: String, clauseValue: String): Boolean {\n      when (operator) {\n        \u0022==\u0022 -\u003e recordValue == clauseValue;\n        \u0022!=\u0022 -\u003e recordValue != clauseValue;\n        \u0022\u003e\u0022 -\u003e recordValue \u003e clauseValue;\n        \u0022\u003c\u0022 -\u003e recordValue \u003c clauseValue;\n        \u0022\u003e=\u0022 -\u003e recordValue \u003e= clauseValue;\n        \u0022\u003c=\u0022 -\u003e recordValue \u003c= clauseValue;\n        else -\u003e false;\n      }\n    }\n\n## SQL Generation\n\nPure functions that produce `SqlFragment` from query state using\nsecure-composition's `sql\u0022...\u0022` tagged strings. Interpolated values are\nautomatically escaped by type. Trusted SQL identifiers (table names, column\nnames, operators) are composed via fragment nesting.\n\n### Operator validation\n\nOnly allow known SQL comparison operators. Returns the operator if valid,\nor `=` as a safe fallback.\n\n    let validOperator(op: String): String {\n      when (op) {\n        \u0022=\u0022 -\u003e \u0022=\u0022;\n        \u0022==\u0022 -\u003e \u0022=\u0022;\n        \u0022!=\u0022 -\u003e \u0022!=\u0022;\n        \u0022\u003c\u003e\u0022 -\u003e \u0022\u003c\u003e\u0022;\n        \u0022\u003e\u0022 -\u003e \u0022\u003e\u0022;\n        \u0022\u003c\u0022 -\u003e \u0022\u003c\u0022;\n        \u0022\u003e=\u0022 -\u003e \u0022\u003e=\u0022;\n        \u0022\u003c=\u0022 -\u003e \u0022\u003c=\u0022;\n        else -\u003e \u0022=\u0022;\n      }\n    }\n\n### Trusted identifier fragment\n\nWraps a trusted identifier (table name, column name, operator) as a\n`SqlFragment`. These come from schema definitions, not user input.\n\n    let safeSql(trusted: String): SqlFragment {\n      let b = new SqlBuilder();\n      b.appendSafe(trusted);\n      b.accumulated\n    }\n\n### Column list helper\n\nBuilds the SELECT column list. If no fields specified, returns `*`.\n\n    let columnListSql(selectFields: List\u003cString\u003e): SqlFragment {\n      if (selectFields.length == 0) {\n        sql\u0022*\u0022\n      } else {\n        let first = safeSql(selectFields[0]);\n        var result = sql\u0022\u0024{first}\u0022;\n        for (var i = 1; i \u003c selectFields.length; i = i + 1) {\n          let col = safeSql(selectFields[i]);\n          result = sql\u0022\u0024{result}, \u0024{col}\u0022;\n        }\n        result\n      }\n    }\n\n### WHERE clause helper\n\nBuilds a single WHERE condition. The value is untrusted user input —\n`sql\u0022...\u0022` escapes it by type automatically.\n\n    let whereConditionSql(clause: WhereClause, schema: Schema): SqlFragment {\n      let col = safeSql(clause.field);\n      let op = safeSql(validOperator(clause.operator));\n      let fieldInfo = schema.getField(clause.field) orelse panic();\n      if (fieldInfo.fieldType == \u0022Int\u0022) {\n        let intVal = clause.value.toInt32() orelse 0;\n        if (clause.value != intVal.toString()) {\n          sql\u00221 = 0\u0022\n        } else {\n          sql\u0022\u0024{col} \u0024{op} \u0024{intVal}\u0022\n        }\n      } else {\n        let strVal = clause.value;\n        sql\u0022\u0024{col} \u0024{op} \u0024{strVal}\u0022\n      }\n    }\n\n### ORDER BY clause helper\n\n    let orderBySql(clauses: List\u003cOrderClause\u003e): SqlFragment {\n      let first = safeSql(clauses[0].field);\n      let firstDir = if (clauses[0].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n      var result = sql\u0022\u0024{first}\u0024{firstDir}\u0022;\n      for (var i = 1; i \u003c clauses.length; i = i + 1) {\n        let col = safeSql(clauses[i].field);\n        let dir = if (clauses[i].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n        result = sql\u0022\u0024{result}, \u0024{col}\u0024{dir}\u0022;\n      }\n      result\n    }\n\n### Full SELECT query builder\n\nAssembles a complete SELECT statement from parts. This is the main pure\nfunction: it takes query state in, returns `SqlFragment` out. Field names\nare validated against the schema — only declared fields pass through\n`safeSql`. Unknown fields are silently dropped, closing the confused deputy\nvector where user-controlled strings could reach `appendSafe`.\n\n    export let toSqlQuery(\n      schema: Schema,\n      selectFields: List\u003cString\u003e,\n      whereClauses: List\u003cWhereClause\u003e,\n      orderClauses: List\u003cOrderClause\u003e,\n      limitValue: Int,\n      offsetValue: Int,\n    ): SqlFragment {\n      let validSelect = selectFields.filter { (f: String): Boolean =\u003e\n        schema.hasField(f)\n      };\n      let validWhere = whereClauses.filter { (c: WhereClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let validOrder = orderClauses.filter { (c: OrderClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let table = safeSql(schema.tableName);\n      let cols = columnListSql(validSelect);\n      var result = sql\u0022SELECT \u0024{cols} FROM \u0024{table}\u0022;\n      if (validWhere.length \u003e 0) {\n        var conditions = whereConditionSql(validWhere[0], schema);\n        for (var i = 1; i \u003c validWhere.length; i = i + 1) {\n          let next = whereConditionSql(validWhere[i], schema);\n          conditions = sql\u0022\u0024{conditions} AND \u0024{next}\u0022;\n        }\n        result = sql\u0022\u0024{result} WHERE \u0024{conditions}\u0022;\n      }\n      if (validOrder.length \u003e 0) {\n        let ordering = orderBySql(validOrder);\n        result = sql\u0022\u0024{result} ORDER BY \u0024{ordering}\u0022;\n      }\n      if (limitValue \u003e= 0) {\n        result = sql\u0022\u0024{result} LIMIT \u0024{limitValue}\u0022;\n      }\n      if (offsetValue \u003e 0) {\n        result = sql\u0022\u0024{result} OFFSET \u0024{offsetValue}\u0022;\n      }\n      result\n    }\n\n### INSERT statement builder\n\nGenerates an INSERT statement from a schema and a map of field values.\nField names come from the schema (trusted). Values are escaped via\n`sql\u0022...\u0022` by type.\n\n    export let toInsertSql(\n      schema: Schema,\n      values: Map\u003cString, String\u003e,\n    ): SqlFragment {\n      let table = safeSql(schema.tableName);\n      let fieldList = schema.fields.filter { (f: Field): Boolean =\u003e\n        values.has(f.name)\n      };\n      if (fieldList.length == 0) {\n        return sql\u0022\u0022;\n      }\n      let colNames = columnListSql(\n        fieldList.map { (f: Field): String =\u003e f.name }\n      );\n      let firstVal = values.getOr(fieldList[0].name, \u0022\u0022);\n      var vals = if (fieldList[0].fieldType == \u0022Int\u0022) {\n        let iv = firstVal.toInt32() orelse 0;\n        sql\u0022\u0024{iv}\u0022\n      } else {\n        sql\u0022\u0024{firstVal}\u0022\n      };\n      for (var i = 1; i \u003c fieldList.length; i = i + 1) {\n        let val = values.getOr(fieldList[i].name, \u0022\u0022);\n        if (fieldList[i].fieldType == \u0022Int\u0022) {\n          let iv = val.toInt32() orelse 0;\n          vals = sql\u0022\u0024{vals}, \u0024{iv}\u0022;\n        } else {\n          vals = sql\u0022\u0024{vals}, \u0024{val}\u0022;\n        }\n      }\n      sql\u0022INSERT INTO \u0024{table} (\u0024{colNames}) VALUES (\u0024{vals})\u0022\n    }\n\n## SQL Generation Tests\n\n### Basic SELECT\n\n    test(\u0022toSql: select all\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n### SELECT with specific columns\n\n    test(\u0022toSql: select columns\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).select([\u0022name\u0022, \u0022age\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name, age FROM users\u0022);\n    }\n\n### WHERE with string value\n\n    test(\u0022toSql: where string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### WHERE with integer value\n\n    test(\u0022toSql: where int\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18\u0022);\n    }\n\n### SQL injection protection\n\nThe Bobby Tables attack string is safely escaped — single quotes are doubled.\n\n    test(\u0022toSql: SQL injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, bobby);\n      let result = q.toSql().toString();\n      assert(result == \u0022SELECT * FROM users WHERE name = 'Robert''); DROP TABLE users;--'\u0022);\n    }\n\n### Operator normalization\n\nThe `==` operator from the in-memory query API is normalized to SQL `=`.\n\n    test(\u0022toSql: operator normalization\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022==\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Invalid operator fallback\n\nUnknown operators fall back to `=` for safety.\n\n    test(\u0022toSql: invalid operator fallback\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022LIKE\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Multiple WHERE clauses\n\n    test(\u0022toSql: multiple where\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .where(\u0022age\u0022, \u0022\u003c\u0022, \u002230\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18 AND age \u003c 30\u0022);\n    }\n\n### ORDER BY\n\n    test(\u0022toSql: order by\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022name\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY name ASC\u0022);\n    }\n\n### ORDER BY descending\n\n    test(\u0022toSql: order by desc\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022age\u0022, \u0022desc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY age DESC\u0022);\n    }\n\n### LIMIT and OFFSET\n\n    test(\u0022toSql: limit\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(10);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 10\u0022);\n    }\n\n    test(\u0022toSql: offset\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).offset(5);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users OFFSET 5\u0022);\n    }\n\n### Complex query\n\n    test(\u0022toSql: complex query\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10)\n        .offset(20);\n      assert(q.toSql().toString() ==\n        \u0022SELECT name, age FROM users WHERE age \u003e= 18 ORDER BY age DESC LIMIT 10 OFFSET 20\u0022);\n    }\n\n### Unicode in values\n\n    test(\u0022toSql: unicode escaping\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Hello 世界\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Hello 世界'\u0022);\n    }\n\n### Embedded quotes in values\n\n    test(\u0022toSql: embedded quotes\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022O'Brien\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'O''Brien'\u0022);\n    }\n\n### Empty string value\n\n    test(\u0022toSql: empty string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = ''\u0022);\n    }\n\n### INSERT statement\n\n    test(\u0022toInsertSql: basic insert\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022INSERT INTO users (name, age) VALUES ('Alice', 25)\u0022);\n    }\n\n### INSERT with injection protection\n\n    test(\u0022toInsertSql: injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Robert'); DROP TABLE users;--\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() ==\n        \u0022INSERT INTO users (name) VALUES ('Robert''); DROP TABLE users;--')\u0022);\n    }\n\n### toSqlQuery as standalone pure function\n\n    test(\u0022toSqlQuery: standalone\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let result = toSqlQuery(\n        s, [\u0022name\u0022], [new WhereClause(\u0022age\u0022, \u0022\u003e\u0022, \u002221\u0022)],\n        [new OrderClause(\u0022name\u0022, \u0022asc\u0022)], 5, 0,\n      );\n      assert(result.toString() ==\n        \u0022SELECT name FROM users WHERE age \u003e 21 ORDER BY name ASC LIMIT 5\u0022);\n    }\n\n### Adversarial field name protection\n\nField names not in the schema are silently dropped from SQL generation.\nThis prevents confused deputy attacks where user-controlled strings\ncould reach `appendSafe` through field name positions.\n\n    test(\u0022toSql: adversarial field name blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u00221=1; DROP TABLE users; --\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial select column blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u00221; DROP TABLE users\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial order by blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .orderBy(\u00221; DROP TABLE users\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n## Security Audit Fix Tests\n\n### Fix #1: Table name validation\n\n    test(\u0022isValidIdentifier: valid names\u0022) {\n      assert(isValidIdentifier(\u0022users\u0022));\n      assert(isValidIdentifier(\u0022user_table\u0022));\n      assert(isValidIdentifier(\u0022Table1\u0022));\n      assert(isValidIdentifier(\u0022_private\u0022));\n      assert(isValidIdentifier(\u0022a\u0022));\n    }\n\n    test(\u0022isValidIdentifier: invalid names\u0022) {\n      assert(!isValidIdentifier(\u0022\u0022));\n      assert(!isValidIdentifier(\u0022users; DROP TABLE\u0022));\n      assert(!isValidIdentifier(\u0022users--\u0022));\n      assert(!isValidIdentifier(\u0022ta ble\u0022));\n      assert(!isValidIdentifier(\u0022table.name\u0022));\n      assert(!isValidIdentifier(\u0022Robert'); DROP TABLE users;--\u0022));\n    }\n\n### Fix #3: Non-numeric value for Int field\n\n    test(\u0022toSql: non-numeric Int value produces always-false\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE 1 = 0\u0022);\n    }\n\n    test(\u0022in-memory: non-numeric Int value matches nothing\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u00220\u0022),\n      ]));\n      let results = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022).all();\n      assert(results.length == 0);\n    }\n\n### Fix #5: LIMIT zero and negative\n\n    test(\u0022toSql: limit zero emits LIMIT 0\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(0);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 0\u0022);\n    }\n\n    test(\u0022in-memory: limit zero returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(0).all();\n      assert(results.length == 0);\n    }\n\n    test(\u0022in-memory: negative limit clamped to zero\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(-5).all();\n      assert(results.length == 0);\n    }\n\n### Fix #6: Empty insert safety\n\n    test(\u0022toInsertSql: no matching fields returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022nonexistent\u0022, \u0022value\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022\u0022);\n    }\n\n## Demo\n\n    export let main(): Void {\n      console.log(\u0022=== ORMery Demo ===\\n\u0022);\n\n      let userFields = [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n        field(\u0022email\u0022, \u0022String\u0022, false, true),\n      ];\n      let userSchema = schema(\u0022users\u0022, userFields);\n\n      console.log(userSchema.describe());\n      console.log(\u0022\u0022);\n\n      let store = new InMemoryStore();\n\n      let rec1 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n        new Pair(\u0022email\u0022, \u0022alice@example.com\u0022),\n      ]));\n\n      let rec2 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Bob\u0022),\n        new Pair(\u0022age\u0022, \u002230\u0022),\n        new Pair(\u0022email\u0022, \u0022bob@example.com\u0022),\n      ]));\n\n      let rec3 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Charlie\u0022),\n        new Pair(\u0022age\u0022, \u002217\u0022),\n        new Pair(\u0022email\u0022, \u0022charlie@example.com\u0022),\n      ]));\n\n      console.log(\u0022Inserted 3 users:\u0022);\n      console.log(\u0022  \u0024{rec1.describe()}\u0022);\n      console.log(\u0022  \u0024{rec2.describe()}\u0022);\n      console.log(\u0022  \u0024{rec3.describe()}\u0022);\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== In-Memory Queries ===\\n\u0022);\n\n      console.log(\u0022All users:\u0022);\n      let allUsers = new Query(userSchema, store).all();\n      for (let u of allUsers) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022Adults (age \u003e= 18):\u0022);\n      let adults = new Query(userSchema, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .all();\n      for (let u of adults) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== SQL Generation (secure-composition) ===\\n\u0022);\n\n      let q1 = new Query(userSchema, store);\n      console.log(\u0022SELECT all: \u0024{q1.toSql().toString()}\u0022);\n\n      let q2 = new Query(userSchema, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10);\n      console.log(\u0022Complex:    \u0024{q2.toSql().toString()}\u0022);\n\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q3 = new Query(userSchema, store)\n        .where(\u0022name\u0022, \u0022=\u0022, bobby);\n      console.log(\u0022Injection:  \u0024{q3.toSql().toString()}\u0022);\n\n      let insertVals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022O'Malley\u0022),\n        new Pair(\u0022age\u0022, \u002242\u0022),\n      ]);\n      console.log(\u0022INSERT:     \u0024{toInsertSql(userSchema, insertVals).toString()}\u0022);\n\n      console.log(\u0022\\n=== Demo Complete ===\u0022);\n    }\n" ], "names": [ "toSqlSelectAll", "test#17", "s", "store", "q", "actual#831", "toSql", "toString", "t#3717", "fn", "assert", "toSqlSelectColumns", "test#18", "select", "actual#834", "t#3708", "toSqlWhereString", "test#19", "where", "actual#837", "t#3698", "toSqlWhereInt", "test#20", "actual#840", "t#3688", "toSqlSqlInjectionBlocked", "test#21", "bobby", "result", "actual#843", "t#3678", "toSqlOperatorNormalization", "test#22", "actual#846", "t#3668", "toSqlInvalidOperatorFallback", "test#23", "actual#849", "t#3658", "toSqlMultipleWhere", "test#24", "actual#852", "t#3648", "toSqlOrderBy", "test#25", "orderBy", "actual#855", "t#3637", "toSqlOrderByDesc", "test#26", "actual#858", "t#3627", "toSqlLimit", "test#27", "limit", "actual#861", "t#3617", "toSqlOffset", "test#28", "offset", "actual#864", "t#3607", "toSqlComplexQuery", "test#29", "actual#867", "t#3597", "toSqlUnicodeEscaping", "test#30", "actual#870", "t#3583", "toSqlEmbeddedQuotes", "test#31", "actual#873", "t#3573", "toSqlEmptyString", "test#32", "actual#876", "t#3563", "toInsertSqlBasicInsert", "test#33", "vals", "actual#879", "t#3553", "toInsertSqlInjectionBlocked", "test#34", "actual#882", "t#3543", "toSqlQueryStandalone", "test#35", "actual#885", "t#3534", "toSqlAdversarialFieldNameBlocked", "test#36", "actual#888", "t#3523", "toSqlAdversarialSelectColumnBlocked", "test#37", "actual#891", "t#3513", "toSqlAdversarialOrderByBlocked", "test#38", "actual#894", "t#3503", "isValidIdentifierValidNames", "test#39", "t#3480", "t#3483", "t#3486", "t#3489", "t#3492", "isValidIdentifierInvalidNames", "test#40", "t#3453", "t#3457", "t#3461", "t#3465", "t#3469", "t#3473", "toSqlNonNumericIntValueProducesAlwaysFalse", "test#41", "actual#899", "t#3443", "inMemoryNonNumericIntValueMatchesNothing", "test#42", "insert", "results", "all", "actual#902", "t#3433", "toSqlLimitZeroEmitsLimit0", "test#43", "actual#905", "t#3417", "inMemoryLimitZeroReturnsEmpty", "test#44", "actual#908", "t#3407", "inMemoryNegativeLimitClampedToZero", "test#45", "actual#911", "t#3392", "toInsertSqlNoMatchingFieldsReturnsEmpty", "test#46", "actual#914", "t#3377" ], "mappings": "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" }