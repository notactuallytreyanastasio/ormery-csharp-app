{ "version": 3, "file": "csharp/ormery/src/Html/UrlEscaperContext.cs", "sources": [ "-work/src/html/safe-html.temper.md" ], "sourcesContent": [ "# Safe HTML\n\nThis module defines contextual auto-escaping tags for HTML, safe\ncontent types, so that frameworks and Temper string expressions can\nsafely combine trusted HTML with untrusted .\n\n    test(\u0022hello world, html style\u0022) {\n      assert(html\u0022Hello, \u003cb\u003e\u0024{\u0022World\u0022}\u003c/b\u003e!\u0022.toString() ==\n                 \u0022Hello, \u003cb\u003eWorld\u003c/b\u003e!\u0022);\n    }\n\n**The `html` tag** identifies the content as HTML, and auto-escapes\ninterpolated values.\n\n    test(\u0022autoescaped\u0022) {\n      assert(html\u00221 + 1 \u0024{\u0022\u003c\u0022} 3.\u0022.toString() ==\n                 \u00221 + 1 \u0026lt; 3.\u0022);\n    }\n\n**Context** matters because languages embed.\nHTML can contain strings in micro-languages: URLs, JavaScript, CSS.\n\nIf we allowed any attacker-controlled URL as the value of an `href` attributes\nthen the attacker can simply use a `javascript:` URL to execute arbitrary\nJavaScript.  Instead, if the interpolation is the first in a URL, we do additional\nfiltering.\n\n    test(\u0022context matters -- URLs embed\u0022) {\n      let okUrl(): String { \u0022https://example.com/isn't-a-problem\u0022 }\n      let evilUrl(): String { \u0022javascript:alert('evil done')\u0022 }\n\n      // https URLs are fine in an href attribute.  As an HTML text node, they're just any other string.\n      assert(html\u0022\u003ca href='\u0024{okUrl()}'\u003e\u0024{okUrl()}\u003c/a\u003e\u0022.toString() ==\n                 \u0022\u003ca href='https://example.com/isn\u0026#39;t-a-problem'\u003ehttps://example.com/isn\u0026#39;t-a-problem\u003c/a\u003e\u0022);\n\n      // javascript URLs are not ok as string inputs.\n      assert(html\u0022\u003ca href='\u0024{evilUrl()}'\u003e\u0024{evilUrl()}\u003c/a\u003e\u0022.toString() ==\n                 \u0022\u003ca href='about:zz_Temper_zz#'\u003ejavascript:alert(\u0026#39;evil done\u0026#39;)\u003c/a\u003e\u0022);\n      //                   ┗━━━━━━━━━━━━━━━━━┛  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n      //                  href attrib context            text node context\n    }\n\nSometimes **adjustments are necessary**.  Here, an attribute value is\ninterpolated with and without quotation marks.  Unquoted attributes\nvalues are legal HTML, but we can significantly reduce the attack\nsurface by consistently quoting attributes.\n\n    test(\u0022quote adjustments\u0022) {\n      let className = 'some-class';\n\n      assert(html\u0022\u003chr class=\u0024{className}\u003e\u003chr class='\u0024{className}'\u003e\u003chr class=other-class\u003e\u0022.toString()\n             ==  \u0022\u003chr class=\\\u0022some-class\\\u0022\u003e\u003chr class='some-class'\u003e\u003chr class=\\\u0022other-class\\\u0022\u003e\u0022);\n    }\n\n\n**Type safe exceptions**.  Here, `love` is a *SafeHtml* value with\ntags, so it composes nicely (no overescaping) when injected in a tag\ncontext.  But in an attribute context, the `html` tag takes care to\npreserve attribute boundaries.\n\n    test(\u0022safehtml injected in tag and attribute context\u0022) {\n      let love = html\u0022I \u003c3 \u003cb\u003ePonies\u003c/b\u003e!\u0022;\n      assert(html\u0022\u003cb\u003e\u0024{love}\u003c/b\u003e\u003cimg alt='\u0024{love}' src='ponies'\u003e\u0022.toString() ==\n                 \u0022\u003cb\u003eI \u0026lt;3 \u003cb\u003ePonies\u003c/b\u003e!\u003c/b\u003e\u003cimg alt='I \u0026lt;3 \u0026lt;b\u0026gt;Ponies\u0026lt;/b\u0026gt;!' src='ponies'\u003e\u0022);\n      //                     ┗━┛ No over-escaping                ┗━━━━━━━┛ Tags not allowed here are defanged.\n    }\n\nComposition libraries work with multi-line string expressions.\n\n    test(\u0022looping inside an HTML expression\u0022) {\n      let items = [\u0022One\u0022, \u0022\u003cTwo\u003e\u0022, \u0022Three\u0022];\n      let got: SafeHtml = html\u0022\u0022\u0022\n        \u0022\u003cul\u003e\n        \u0022  {: for (let item of items) { :}\n        \u0022  \u003cli\u003e\u0024{item}\u003c/li\u003e\n        \u0022  {: } :}\n        \u0022\u003c/ul\u003e\n        ;\n      assert(\n        got.text ==\n        \u0022\u0022\u0022\n          \u0022\u003cul\u003e\n          \u0022  \u003cli\u003eOne\u003c/li\u003e\n          \u0022  \u003cli\u003e\u0026lt;Two\u0026gt;\u003c/li\u003e\n          \u0022  \u003cli\u003eThree\u003c/li\u003e\n          \u0022\u003c/ul\u003e\n        );\n    }\n\n## Context type definitions\n\nHtmlEscaperContext represents a path into an HTML grammar that allows pausable\nparsing of HTML with holes.\n\n    export class HtmlEscaperContext(\n\nhtmlState describes where the parser is in the HTML parsing algorithm.\n\n      public htmlState: Int32,\n\ntagState describes any special tag the HTML parser is in.\nFor example, inside a tag, it describes that tag.\nIn the body of a special tag, e.g. `\u003cscript\u003e` or `\u003cstyle\u003e` it captures\nthe state exit conditions, for example, a `\u003c/script\u003e` exits the special element.\n\n      public tagState: Int32,\n\nattribState describes the kind of attribute being parsed.\nFor example, for `src=\u0022...\u0022` we might need to know that the `...` is a URL embedded\nin HTML, or in `onclick=\u0022...\u0022` that the value is JavaScript embedded in HTML.\n\n      public attribState: Int32,\n\ndelimState identifies the kind of quotation mark for the current attribute value.\n\n      public delimState: Int32,\n\n    ) extends Context {\n      public toString(): String {\n        \u0022HtmlEscaperContext(\u0024{htmlStateStr(htmlState)}, \u0024{tagStateStr(tagState)}, \u0024{attribStateStr(attribState)}, \u0024{delimStateStr(delimState)})\u0022\n      }\n    }\n\nOur initial HtmlEscaperContext just has zeroes/empties for everything.\n\nJsEscaperContext tracks parsing in trusted JavaScript.\n\n    class JsEscaperContext(\n\njsState allows for streaming parsing of JavaScript in script elements\nand event handler attributes.  This state requires being able to track\nwhether a `/` starts a regular expression or a division operator.\n\nThe jsState tracks states in the [JS2.0 lexical grammar][js20-lexer-grammar],\nadjusted to deal with more modern constructs like backtick strings.\nThat lexical grammar was an experiment. It is approximate but highly accurate,\nand sufficient since our threat model excludes obfuscated, trusted string parts.\n*jsState* captures the kind of token we're in along with the (re, div, unit) bits.\n\n      public jsState: Int32,\n\njsStack provides additional JavaScript parsing context.  Handling\nnested interpolations in backtick strings requires knowing whether a\n`}` ends an interpolation or is a regular token.\n\n      public jsStack: List\u003cBoolean\u003e,\n    ) extends Context {\n      public toString(): String { \u0022JsEscaperContext(\u0024{jsState})\u0022 }\n    }\n\nCssEscaperContext captures enough state to allow safe inerpolation\ninto `\u003cstyle\u003e` element bodies and `style=` attribute values.\n\n    class CssEscaperContext(\n      public cssState: Int32,\n    ) extends Context {\n      public toString(): String { \u0022CssEscaperContext(\u0024{cssState})\u0022 }\n    }\n\nUrlEscaperContext captures enough state to allow safe interpolation\ninto attribute values that have URL content.\nIt allows distinguishing between interpolations:\n\n- at the start of a URL where attacker content may control the scheme\n- into a path part where interpolations control path resolution\n- into a query parameter where `=` and `\u0026` are significant meta-characters\n- into a fragment\n\nThe exact escaper chosen allows for high quality of service in URL composition.\n\n    export class UrlEscaperContext(\n      public urlState: Int32,\n    ) extends Context {\n      public toString(): String { \u0022UrlEscaperContext(\u0024{urlStateStr(urlState)})\u0022 }\n    }\n\nThese constants have names prefixed with the state they control.\n\nHere are the possible html state values.\n\n    /** Not in a tag */\n    let htmlStatePcdata = 0;\n    /** In an open tag name, after `\u003c`. */\n    let htmlStateOName = 1;\n    /** In a close tag name, after `\u003c/`. */\n    let htmlStateCName = 2;\n    /** In an open tag, separated from the tag name or preceding attribute value. */\n    let htmlStateBeforeAttr = 3;\n    /** In an open tag, saw an attribute name, but not the `=`. */\n    let htmlStateBeforeEq = 4;\n    /** In an open tag, saw an attribute name and the `=`. */\n    let htmlStateBeforeValue = 5;\n    /** In an attribute value.  The delimState specifies the kind of delimiter and the exit conditions. */\n    let htmlStateAttr = 6;\n    /** After an attribute value including any close delimiter. This state does some cleanup and auto-transitions to another. */\n    let htmlStateAfterAttr = 7;\n    /**\n     * In a context where we're handling the body of a special tag,\n     * specified by tagState, and need to look for its special exit condition.\n     * For example, `\u003c/script\u003e` exits a `\u003cscript\u003e` element body.\n     */\n    let htmlStateSpecialBody = 8;\n\n    /** An attribute with no specific content type */\n    let attribStateGeneric = 0;\n    /** An attribute whose value requires CSS processing */\n    let attribStateCss = 1;\n    /** An attribute whose value requires Js processing */\n    let attribStateJs = 2;\n    /** An attribute whose value requires URL processing */\n    let attribStateUrl = 3;\n    /** An attribute whose value requires processing as a comma-separated list of URLs */\n    let attribStateUrls = 4;\n\n    /**\n     * An unquoted attribute which we insert double quotes around to reduce the attack surface.\n     * E.g. `\u003cimg alt=look_ma_no_quotes\u003e`\n     */\n    let delimStateUq = 0;\n    /** A double quoted attribute. E.g. `\u003cimg alt=\u0022I am double quoted\u0022\u003e` */\n    let delimStateSq = 1;\n    /** A single quoted attribute. E.g. `\u003cimg alt='I am single quoted'\u003e` */\n    let delimStateDq = 2;\n\n    /**\n     * The state at the start of a URL. Attackers who can inject content here may control the protocol.\n     * A common technique is to inject `javascript:badCode()#`, so interpolations here are more heavily\n     * filtered than other locations in the URL.\n     */\n    let urlStateStart = 0;\n    /**\n     * The state in a URL before a `?` or `#` have been seen.\n     * Interpolations here might be URL prefixes with their own queries or fragments,\n     * but may just be path parts.\n     */\n    let urlStateBeforeQuery = 1;\n    /**\n     * The state in a URL after a `?` has been seen in a trusted portion, but before\n     * any `#` has been seen.  Interpolations here are assumed to be query parameter\n     * parts, so URL metacharacters (`\u0026`, `#`, `+`, and `%`) are percent-escaped.\n     *\n     * TODO: An inerpolated iterable of pairs may be encoded as a series of separate URL\n     * key-value pairs.\n     */\n    let urlStateQuery = 2;\n    /**\n     * The state in a URL after a `#` has been seen in a trusted portion.\n     * There are no agreed upon conventions for encoding structured data in a fragment,\n     * but we do encoding similar to the query part.\n     */\n    let urlStateFragment = 3;\n\n## The `html` tag\n\nhtml is a tag for string expressions that applies contextual auto-escaping to untrusted\nexpressions to render them safe.  It embeds knowledge of HTML and nesting languages to\nprovide a much higher level of safety than na\u0026iuml;ve auto-escaping.\n\n    export let html = SafeHtmlBuilder;\n\nSafeHtml is a string wrapper for HTML text that is trusted.\nIt should only be constructed when it is known safe by construction.\nFor example, the auto-escaping HTML tag produces it, but it may be created by other reliable sources:\ne.g. an escaping function that defangs all HTML meta-characters, and a carefully reviewed HTML sanitizer.\n\n    export class SafeHtml(public text: String) {\n      public toString(): String { text }\n    }\n\nSafeUrl is a string wrapper for URL content that is trusted.\nIt should only be constructed when it is known safe by construction.\n\n    export class SafeUrl(public text: String) {\n      public toString(): String { text }\n    }\n\n## Picking escapers\n\n    export sealed interface HtmlEscaper extends Escaper {\n      @overload(\u0022apply\u0022)\n      applySafeHtml(x: SafeHtml): String;\n      @overload(\u0022apply\u0022)\n      applySafeUrl(x: SafeUrl): String;\n      @overload(\u0022apply\u0022)\n      applyInt32(x: Int32): String;\n      @overload(\u0022apply\u0022)\n      applyInt64(x: Int64): String;\n      @overload(\u0022apply\u0022)\n      applyFloat64(x: Float64): String;\n      @overload(\u0022apply\u0022)\n      applyString(x: String): String;\n    }\n\n    /** Defangs interpolations in weird locations.  TODO: These should be reported at compile time. */\n    export class OutputHtmlSpaceEscaper extends HtmlEscaper {\n      public static instance = new OutputHtmlSpaceEscaper();\n      @overload(\u0022apply\u0022)\n      public applySafeHtml(x: SafeHtml): String { \u0022 \u0022 }\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): String { \u0022 \u0022 }\n      @overload(\u0022apply\u0022)\n      public applyInt32(x: Int32): String { \u0022 \u0022 }\n      @overload(\u0022apply\u0022)\n      public applyInt64(x: Int64): String { \u0022 \u0022 }\n      @overload(\u0022apply\u0022)\n      public applyFloat64(x: Float64): String { \u0022 \u0022 }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): String { \u0022 \u0022 }\n    }\n    let outputHtmlSpaceEscaper = doPure { (): OutputHtmlSpaceEscaper =\u003e new OutputHtmlSpaceEscaper() };\n\n    /** Encodes HTML meta-characters using HTML entities in a way that preserves tag boundaries. */\n    export class HtmlPcdataEscaper extends HtmlEscaper {\n      public static instance = new HtmlPcdataEscaper();\n      @overload(\u0022apply\u0022)\n      public applySafeHtml(x: SafeHtml): String { x.toString() }\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): String { applyString(x.text) }\n      @overload(\u0022apply\u0022)\n      public applyInt32(x: Int32): String { applyString(x.toString()) }\n      @overload(\u0022apply\u0022)\n      public applyInt64(x: Int64): String { applyString(x.toString()) }\n      @overload(\u0022apply\u0022)\n      public applyFloat64(x: Float64): String { applyString(x.toString()) }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): String { htmlCodec.encode(x) }\n    }\n    let htmlPcdataEscaper = doPure { (): HtmlPcdataEscaper =\u003e new HtmlPcdataEscaper() };\n\n    /** Encodes HTML meta-characters using HTML entities in a way that preserves attribute boundaries. */\n    export class HtmlAttributeEscaper extends HtmlEscaper {\n      public static instance = new HtmlAttributeEscaper();\n      @overload(\u0022apply\u0022)\n      public applySafeHtml(x: SafeHtml): String { applyString(htmlCodec.decode(x.text)) }\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): String { applyString(x.text) }\n      @overload(\u0022apply\u0022)\n      public applyInt32(x: Int32): String { applyString(x.toString()) }\n      @overload(\u0022apply\u0022)\n      public applyInt64(x: Int64): String { applyString(x.toString()) }\n      @overload(\u0022apply\u0022)\n      public applyFloat64(x: Float64): String { applyString(x.toString()) }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): String { htmlCodec.encode(x) }\n    }\n    let htmlAttributeEscaper = doPure { (): HtmlAttributeEscaper =\u003e new HtmlAttributeEscaper() };\n\n    export let pickHtmlEscaper(stateBefore: AutoescState\u003cHtmlEscaperContext\u003e): HtmlEscaper {\n      var escaper: HtmlEscaper = when (stateBefore.context.htmlState) {\n        htmlStatePcdata -\u003e htmlPcdataEscaper;\n        htmlStateOName, htmlStateCName, htmlStateBeforeAttr, htmlStateBeforeEq, htmlStateAfterAttr -\u003e outputHtmlSpaceEscaper;\n        htmlStateBeforeValue -\u003e panic(); // We should have shifted into an unquoted attribute state\n        htmlStateAttr -\u003e htmlAttributeEscaper;\n        htmlStateSpecialBody -\u003e outputHtmlSpaceEscaper; // TODO\n        else -\u003e panic();\n      }\n      let subsidiary = stateBefore.subsidiary;\n      if (subsidiary != null) {\n        let delegate = (subsidiary.delegate as HtmlDelegate) orelse panic();\n        delegate.escaper(escaper)\n      } else {\n        escaper\n      }\n    }\n\n    export class HtmlEscaperPicker extends EscaperPicker\u003cHtmlEscaperContext, HtmlEscaper\u003e {\n      public escaperFor(stateBefore: AutoescState\u003cHtmlEscaperContext\u003e): HtmlEscaper {\n        pickHtmlEscaper(stateBefore)\n      }\n    }\n\n## Transition tables\n\nThese tables define automata that can progressively parse a stream of\nchunks in a language and propagate contexts.  From a context, we can\npropagate context across safe chunks and the escaper pickers know how\nto pick an escaper for untrusted content.\n\nThe transition tables define context propagation function.  Sometimes\none language embeds another, and these tables also capture when one\nautomaton pushes a subsidiary for a nested language, how it feeds it\ncontent, and when a subsidiary is retired at the end of a nesting\nregion.\n\n### HTML Transition table\n\n\u003c!-- TRANSITION_TABLE: Html; htmlState, tagState, attribState, delimState --\u003e\n\n| In                    | Regex                                     | Substitution | Out                                                 |\n| --------------------- | ----------------------------------------- | ------------ | -------------------------------------------------   |\n| Pcdata,      _, _, _  | `\u003c\\/(?=[a-zA-Z])`                         |              | CName,       _, _,   _                              |\n| Pcdata,      _, _, _  | `\u003c(?=[a-zA-Z])`                           |              | OName,       _, _,   _                              |\n| Pcdata,      _, _, _  | `\u003c`                                       | `\u0026lt;`       | _,           _, _,   _                              |\n| Pcdata,      _, _, _  | `\u003e`                                       | `\u0026gt;`       | _,           _, _,   _                              |\n| Pcdata,      _, _, _  | `[^\u003c\u003e]+`                                  |              | _,           _, _,   _                              |\n| CName,       _, _, _  | `\u0022[^\u0022]*\u0022?`                                |              | _,           _, _,   _                              |\n| CName,       _, _, _  | `'[^']*'?`                                |              | _,           _, _,   _                              |\n| CName,       _, _, _  | `[^\u003e]`                                    |              | _,           _, _,   _                              |\n| CName,       _, _, _  | `\u003e`                                       |              | Pcdata,      _, _,   _                              |\n| OName,       _, _, _  | `[a-zA-Z][a-zA-Z0-9:\\-]*`                 |              | _,           _, _,   _                              |\n| OName,       _, _, _  | `(?=\u003e)`                                   |              | BeforeAttr,  _, _,   _                              |\n| OName,       _, _, _  | `\\s+`                                     |              | BeforeAttr,  _, _,   _                              |\n| BeforeAttr,  _, _, _  | `\\s+`                                     |              | _,           _, _,   _                              |\n| BeforeAttr,  _, _, _  | `[a-zA-Z0-9\\-]+:`                         |              | _,           _, _,   _                              |\n| BeforeAttr,  _, _, _  | `(?i)(?:srcset)(?![a-z0-9:\\-])`           |              | BeforeEq,    _,Urls, _; push(Url, htmlCodec)        |\n| BeforeAttr,  _, _, _  | `(?i)(?:src/href)(?![a-z0-9:\\-])`         |              | BeforeEq,    _,Url,  _; push(Url, htmlCodec)        |\n| BeforeAttr,  _, _, _  | `(?i)data-[^=\\s\u003e]*ur[li][^=\\s\u003e]*`         |              | BeforeEq,    _,Url,  _; push(Url, htmlCodec)        |\n| BeforeAttr,  _, _, _  | `(?i)style(?![a-z0-9:\\-])`                |              | BeforeEq,    _,Css,  _; push(Css, htmlCodec)        |\n| BeforeAttr,  _, _, _  | `(?i)on[^=\\s\u003e]*`                          |              | BeforeEq,    _,Js,   _; push(Js,  htmlCodec)        |\n| BeforeAttr,  _, _, _  | `[^=\u003e\\s]+`                                |              | BeforeEq,    _, _,   _                              |\n| BeforeEq,    _, _, _  | `\\s+`                                     |              | _,           _, _,   _                              |\n| BeforeEq,    _, _, _  | `=`                                       |              | BeforeValue, _, _,   _                              |\n| BeforeEq,    _, _, _  | `(?=\\s*\\/?\u003e)`                             |              | AfterAttr,   _, _,   _                              |\n| BeforeValue, _, _, _  | `\u0022`                                       |              | Attr,        _, _,   Dq                             |\n| BeforeValue, _, _, _  | `'`                                       |              | Attr,        _, _,   Sq                             |\n| BeforeValue, _, _, _  | `(?=[^\u003e\\s])`                              | `\u0022`          | Attr,        _, _,   Uq                             |\n| BeforeValue, _, _, _  | \u0024{}                                       | `\u0022`          | Attr,        _, _,   Uq                             |\n| Attr,        _, _, Uq | `(?=[\u003e\\s])`                               | `\u0022`          | AfterAttr,   _, _,   0                              |\n| Attr,        _, _, Dq | `\u0022`                                       |              | AfterAttr,   _, _,   0                              |\n| Attr,        _, _, Sq | `'`                                       |              | AfterAttr,   _, _,   0                              |\n| Attr,        _,Urls,_ | `,`                                       |              | _,           _, _,   _; pop(); push(Url, htmlCodec) |\n| Attr,        _, _, Uq | `[^\u003e\\s\u0022]+`                                |              | _,           _, _,   _; feed()                      |\n| Attr,        _, _, Uq | `\u0022`                                       | `\u0026#34;`      | _,           _, _,   _; feed()                      |\n| Attr,        _, _, Dq | `[^\u0022]+`                                   |              | _,           _, _,   _; feed()                      |\n| Attr,        _, _, Sq | `[^']+`                                   |              | _,           _, _,   _; feed()                      |\n| Attr,        _, 0, _  | \u0024{}                                       |              | _,           _, _,   _                              |\n| Attr,        _, _, _  | \u0024{}                                       |              | _,           _, _,   _; feed()                      |\n| AfterAttr,   _, 0, _  |                                           |              | BeforeAttr,  _, _,   _                              |\n| AfterAttr,   _, _, _  |                                           |              | BeforeAttr,  _, 0,   _; pop()                       |\n| BeforeAttr,  _, _, _  | `\u003e`                                       |              | Pcdata,      _, _,   _                              |\n| _,           _, _, _  | \u0024{}                                       |              | _,           _, _,   _                              |\n\n\u003c!-- /TRANSITION_TABLE --\u003e\n\n\u003c!-- GENERATED_TRANSITION_DIAGRAM: Html; htmlState --\u003e\n\n```mermaid\nstateDiagram-v2\n  state \u0022htmlStatePcdata\u0022 as htmlStatePcdata\n  state \u0022htmlStateCName\u0022 as htmlStateCName\n  htmlStatePcdata --\u003e htmlStateCName: #96;\u003c\\/(?=[a-zA-Z])#96;\n  state \u0022htmlStateOName\u0022 as htmlStateOName\n  htmlStatePcdata --\u003e htmlStateOName: #96;\u003c(?=[a-zA-Z])#96;\n  htmlStatePcdata --\u003e htmlStatePcdata: #96;\u003c#96;\\n#96;\u0026lt;#96;\n  htmlStatePcdata --\u003e htmlStatePcdata: #96;\u003e#96;\\n#96;\u0026gt;#96;\n  htmlStatePcdata --\u003e htmlStatePcdata: #96;[^\u003c\u003e]+#96;\n  htmlStateCName --\u003e htmlStateCName: #96;\u0022[^\u0022]*\u0022?#96;\n  htmlStateCName --\u003e htmlStateCName: #96;'[^']*'?#96;\n  htmlStateCName --\u003e htmlStateCName: #96;[^\u003e]#96;\n  htmlStateCName --\u003e htmlStatePcdata: #96;\u003e#96;\n  htmlStateOName --\u003e htmlStateOName: #96;[a-zA-Z][a-zA-Z0-9#58;\\-]*#96;\n  state \u0022htmlStateBeforeAttr\u0022 as htmlStateBeforeAttr\n  htmlStateOName --\u003e htmlStateBeforeAttr: #96;(?=\u003e)#96;\n  htmlStateOName --\u003e htmlStateBeforeAttr: #96;\\s+#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeAttr: #96;\\s+#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeAttr: #96;[a-zA-Z0-9\\-]+#58;#96;\n  state \u0022htmlStateBeforeEq\u0022 as htmlStateBeforeEq\n  htmlStateBeforeAttr --\u003e htmlStateBeforeEq: #96;(?i)(?#58;srcset)(?![a-z0-9#58;\\-])#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeEq: #96;(?i)(?#58;src/href)(?![a-z0-9#58;\\-])#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeEq: #96;(?i)data-[^=\\s\u003e]*ur[li][^=\\s\u003e]*#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeEq: #96;(?i)style(?![a-z0-9#58;\\-])#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeEq: #96;(?i)on[^=\\s\u003e]*#96;\n  htmlStateBeforeAttr --\u003e htmlStateBeforeEq: #96;[^=\u003e\\s]+#96;\n  htmlStateBeforeEq --\u003e htmlStateBeforeEq: #96;\\s+#96;\n  state \u0022htmlStateBeforeValue\u0022 as htmlStateBeforeValue\n  htmlStateBeforeEq --\u003e htmlStateBeforeValue: #96;=#96;\n  state \u0022htmlStateAfterAttr\u0022 as htmlStateAfterAttr\n  htmlStateBeforeEq --\u003e htmlStateAfterAttr: #96;(?=\\s*\\/?\u003e)#96;\n  state \u0022htmlStateAttr\u0022 as htmlStateAttr\n  htmlStateBeforeValue --\u003e htmlStateAttr: #96;\u0022#96;\n  htmlStateBeforeValue --\u003e htmlStateAttr: #96;'#96;\n  htmlStateBeforeValue --\u003e htmlStateAttr: #96;(?=[^\u003e\\s])#96;\\n#96;\u0022#96;\n  htmlStateBeforeValue --\u003e htmlStateAttr: \u0024{}\\n#96;\u0022#96;\n  htmlStateAttr --\u003e htmlStateAfterAttr: #96;(?=[\u003e\\s])#96;\\n#96;\u0022#96;\n  htmlStateAttr --\u003e htmlStateAfterAttr: #96;\u0022#96;\n  htmlStateAttr --\u003e htmlStateAfterAttr: #96;'#96;\n  htmlStateAttr --\u003e htmlStateAttr: #96;,#96;\n  htmlStateAttr --\u003e htmlStateAttr: #96;[^\u003e\\s\u0022]+#96;\n  htmlStateAttr --\u003e htmlStateAttr: #96;\u0022#96;\\n#96;\u0026#35;34;#96;\n  htmlStateAttr --\u003e htmlStateAttr: #96;[^\u0022]+#96;\n  htmlStateAttr --\u003e htmlStateAttr: #96;[^']+#96;\n  htmlStateAttr --\u003e htmlStateAttr: \u0024{}\n  htmlStateAttr --\u003e htmlStateAttr: \u0024{}\n  htmlStateAfterAttr --\u003e htmlStateBeforeAttr\n  htmlStateAfterAttr --\u003e htmlStateBeforeAttr\n  htmlStateBeforeAttr --\u003e htmlStatePcdata: #96;\u003e#96;\n  state \u0022_\u0022 as _\n  _ --\u003e _: \u0024{}\n```\n\n\u003c!-- /GENERATED_TRANSITION_DIAGRAM --\u003e\n\n### URL Transition table\n\n\u003c!-- TRANSITION_TABLE: Url; urlState --\u003e\n\n| In                    | Regex                | Substitution | Out         |\n| --------------------- | -------------------- | ------------ | ----------- |\n| Start                 | `[^:#?]*:/[^\\s:#?]`  |              | BeforeQuery |\n| Start                 | `[?]`                |              | Query       |\n| Start                 | `[#]`                |              | Fragment    |\n| BeforeQuery           | `[^?#]+`             |              | _           |\n| BeforeQuery           | `[?]`                |              | Query       |\n| BeforeQuery           | `[#]`                |              | Fragment    |\n| Query                 | `[^#]+`              |              | _           |\n| Query                 | `[#]`                |              | Fragment    |\n| _                     | \u0024{}                  |              | _           |\n\n\u003c!-- /TRANSITION_TABLE --\u003e\n\n\u003c!-- GENERATED_TRANSITION_DIAGRAM: Url; urlState --\u003e\n\n```mermaid\nstateDiagram-v2\n  state \u0022urlStateStart\u0022 as urlStateStart\n  state \u0022urlStateBeforeQuery\u0022 as urlStateBeforeQuery\n  urlStateStart --\u003e urlStateBeforeQuery: #96;[^#58;#35;?]*#58;/[^\\s#58;#35;?]#96;\n  state \u0022urlStateQuery\u0022 as urlStateQuery\n  urlStateStart --\u003e urlStateQuery: #96;[?]#96;\n  state \u0022urlStateFragment\u0022 as urlStateFragment\n  urlStateStart --\u003e urlStateFragment: #96;[#35;]#96;\n  urlStateBeforeQuery --\u003e urlStateBeforeQuery: #96;[^?#35;]+#96;\n  urlStateBeforeQuery --\u003e urlStateQuery: #96;[?]#96;\n  urlStateBeforeQuery --\u003e urlStateFragment: #96;[#35;]#96;\n  urlStateQuery --\u003e urlStateQuery: #96;[^#35;]+#96;\n  urlStateQuery --\u003e urlStateFragment: #96;[#35;]#96;\n  state \u0022_\u0022 as _\n  _ --\u003e _: \u0024{}\n```\n\n\u003c!-- /GENERATED_TRANSITION_DIAGRAM --\u003e\n\n## Autoescaping builder implementation\n\n    export class SafeHtmlBuilder extends ContextualAutoescapingAccumulator\u003cHtmlEscaperContext, HtmlEscaper\u003e {\n      public static newCollector(): StringBuilder { new StringBuilder() }\n      public static initialState(): AutoescState\u003cHtmlEscaperContext\u003e { new AutoescState(new HtmlEscaperContext(0, 0, 0, 0), null) }\n      public static propagator(): HtmlContextPropagator { new HtmlContextPropagator() }\n      public static picker(): EscaperPicker\u003cHtmlEscaperContext, HtmlEscaper\u003e { new HtmlEscaperPicker() }\n      public static fromCollector(collector: StringBuilder): SafeHtml {\n        new SafeHtml(collector.toString())\n      }\n      public static mergeStates(a: AutoescState\u003cHtmlEscaperContext\u003e, b: AutoescState\u003cHtmlEscaperContext\u003e): AutoescState\u003cHtmlEscaperContext\u003e {\n        // TODO\n        a\n      }\n\n      private var _state: AutoescState\u003cHtmlEscaperContext\u003e = SafeHtmlBuilder.initialState();\n      private collector: StringBuilder = SafeHtmlBuilder.newCollector();\n\n      protected get state(): AutoescState\u003cHtmlEscaperContext\u003e { this._state }\n      protected set state(x: AutoescState\u003cHtmlEscaperContext\u003e): Void { this._state = x; }\n      public get escaperPicker(): EscaperPicker\u003cHtmlEscaperContext, HtmlEscaper\u003e { SafeHtmlBuilder.picker() }\n      public get contextPropagator(): ContextPropagator\u003cHtmlEscaperContext\u003e { SafeHtmlBuilder.propagator() }\n\n      public get accumulated(): SafeHtml {\n        SafeHtmlBuilder.fromCollector(collector)\n      }\n\n      protected collectFixed(fixed: String): Void {\n        collector.append(fixed);\n      }\n\n      @overload(\u0022append\u0022)\n      public appendSafeHtml(x: SafeHtml): Void {\n        collector.append(this.prepareForAppend().applySafeHtml(x));\n      }\n      @overload(\u0022append\u0022)\n      public appendSafeUrl(x: SafeUrl): Void {\n        collector.append(this.prepareForAppend().applySafeUrl(x));\n      }\n      @overload(\u0022append\u0022)\n      public appendInt32(x: Int32): Void {\n        collector.append(this.prepareForAppend().applyInt32(x));\n      }\n      @overload(\u0022append\u0022)\n      public appendInt64(x: Int64): Void {\n        collector.append(this.prepareForAppend().applyInt64(x));\n      }\n      @overload(\u0022append\u0022)\n      public appendFloat64(x: Float64): Void {\n        collector.append(this.prepareForAppend().applyFloat64(x));\n      }\n      @overload(\u0022append\u0022)\n      public appendString(x: String): Void {\n        collector.append(this.prepareForAppend().applyString(x));\n      }\n    }\n\n## Delegation\n\nThe HTML autoescaper needs to delegate to auto-escapers that nest within HTML.\n\n    export sealed interface HtmlDelegate extends Delegate {\n      escaper(outer: HtmlEscaper): HtmlEscaper;\n    }\n\n    export class HtmlUrlDelegate extends ContextDelegate\u003cUrlEscaperContext\u003e \u0026 HtmlDelegate {\n      private var _state: AutoescState\u003cUrlEscaperContext\u003e = new AutoescState\u003cUrlEscaperContext\u003e(new UrlEscaperContext(0), null);\n      private var _subsidiary: Subsidiary? = null;\n\n      protected get state(): AutoescState\u003cUrlEscaperContext\u003e { _state }\n      protected set state(x: AutoescState\u003cUrlEscaperContext\u003e): Void { _state = x; }\n\n      protected get contextPropagator(): ContextPropagator\u003cUrlEscaperContext\u003e {\n        urlContextPropagator\n      }\n\n      public escaper(outer: HtmlEscaper): HtmlEscaper {\n        when (state.context.urlState) {\n          urlStateStart -\u003e new HtmlUrlEscaperAdapter(htmlProtocolFilteringUrlEscaper, outer);\n          urlStateBeforeQuery -\u003e new HtmlUrlEscaperAdapter(htmlUrlPartUrlEscaper, outer);\n          urlStateQuery, urlStateFragment -\u003e new HtmlUrlEscaperAdapter(htmlAsIfQueryUrlEscaper, outer);\n          else -\u003e panic();\n        }\n      }\n    }\n\n    export class HtmlUrlEscaperAdapter(\n      public first: UrlEscaper,\n      public second: HtmlEscaper,\n    ) extends HtmlEscaper {\n      @overload(\u0022apply\u0022)\n      public applySafeHtml(x: SafeHtml): String {\n        second.applySafeUrl(first.applyString(x.text))\n      }\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): String {\n        second.applySafeUrl(first.applySafeUrl(x))\n      }\n      @overload(\u0022apply\u0022)\n      public applyInt32(x: Int32): String {\n        second.applySafeUrl(first.applyString(x.toString()))\n      }\n      @overload(\u0022apply\u0022)\n      public applyInt64(x: Int64): String {\n        second.applySafeUrl(first.applyString(x.toString()))\n      }\n      @overload(\u0022apply\u0022)\n      public applyFloat64(x: Float64): String {\n        second.applySafeUrl(first.applyString(x.toString()))\n      }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): String {\n        second.applySafeUrl(first.applyString(x))\n      }\n    }\n\n    export sealed interface UrlEscaper extends Escaper {\n      @overload(\u0022apply\u0022)\n      applySafeUrl(x: SafeUrl): SafeUrl;\n      @overload(\u0022apply\u0022)\n      applyString(x: String): SafeUrl;\n    }\n\n    let protocolAllowList = rgx\u0022^(?:[Hh][Tt][Tt][Pp][Ss]?|[Mm][Aa][Ii][Ll][Tt][Oo])\u0024\u0022;\n    let fallbackSafeUrl = new SafeUrl(\u0022about:zz_Temper_zz#\u0022);\n\n    export class HtmlProtocolFilteringUrlEscaper extends UrlEscaper {\n      public static instance = new HtmlProtocolFilteringUrlEscaper();\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): SafeUrl { x }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): SafeUrl {\n        var protocolEnd = String.begin;\n        let end = x.end;\n        while (protocolEnd \u003c end) {\n          let cp = x[protocolEnd];\n          if (cp == char':') {\n            let protocol = x.slice(String.begin, protocolEnd);\n            return if ((protocolAllowList.find(protocol) orelse null) != null) {\n              // Protocol is explicitly allowed\n              new SafeUrl(x)\n            } else {\n              fallbackSafeUrl\n            }\n          }\n          protocolEnd = x.next(protocolEnd);\n        }\n        // No protocol, just process it as a string content.\n        htmlUrlPartUrlEscaper.applyString(x)\n      }\n    }\n    let htmlProtocolFilteringUrlEscaper = doPure { (): HtmlProtocolFilteringUrlEscaper =\u003e\n      new HtmlProtocolFilteringUrlEscaper()\n    };\n\n    /**\n     * We %-escape every ASCII codepoint but\n     * - letters and digits [A-Za-z0-9]\n     * - path separators, dots, dashes, underscores\n     */\n    let urlQuerySafe: List = do {\n      let lb = new ListBuilder\u003cBoolean\u003e();\n      for (var i = 0; i \u003c 128; ++i) {\n        lb.add(\n          i == char'/' || i == char'.' || i == char'-' || i == char'_' ||\n          char'0' \u003c= i \u0026\u0026 i \u003c= char'9' || char'a' \u003c= (i | 32) \u0026\u0026 (i | 32) \u003c= char'z'\n        );\n      }\n      lb.toList()\n    };\n    /**\n     * Outside of a query or fragment we also allow common HTML metacharacters: ':', '?', '#', '\u0026'.\n     * That allows embedding full URL prefixes in a string.\n     */\n    let urlSafe: List\u003cBoolean\u003e = do {\n      let lb = new ListBuilder\u003cBoolean\u003e();\n      for (var i = 0; i \u003c 128; ++i) {\n        lb.add(\n          urlQuerySafe[i] || i == char':' || i == char'?' || i == char'#' || i == char'\u0026'\n        );\n      }\n      lb.toList()\n    }\n\n    export class HtmlUrlPartUrlEscaper extends UrlEscaper {\n      public static instance = new HtmlUrlPartUrlEscaper();\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): SafeUrl { x }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): SafeUrl {\n        var i = String.begin;\n        let end = x.end;\n        var emitted = String.begin;\n        let sb = new StringBuilder();\n        while (i \u003c end) {\n          let cp = x[i];\n          if (cp \u003c urlSafe.length \u0026\u0026 !urlSafe[cp]) {\n            sb.appendBetween(x, emitted, i);\n            percentEscapeOctetTo(cp, sb);\n            emitted = x.next(i);\n          }\n          i = x.next(i);\n        }\n        new SafeUrl(\n          if (emitted \u003e String.begin) {\n            sb.appendBetween(x, emitted, end);\n            sb.toString()\n          } else {\n            x\n          }\n        )\n      }\n    }\n    let htmlUrlPartUrlEscaper = doPure { (): HtmlUrlPartUrlEscaper =\u003e new HtmlUrlPartUrlEscaper() };\n\n    export class HtmlAsIfQueryUrlEscaper extends UrlEscaper {\n      public static instance = new HtmlAsIfQueryUrlEscaper();\n      @overload(\u0022apply\u0022)\n      public applySafeUrl(x: SafeUrl): SafeUrl { x }\n      @overload(\u0022apply\u0022)\n      public applyString(x: String): SafeUrl {\n        var i = String.begin;\n        let end = x.end;\n        var emitted = String.begin;\n        let sb = new StringBuilder();\n        while (i \u003c end) {\n          let cp = x[i];\n          if (cp \u003c urlQuerySafe.length \u0026\u0026 !urlQuerySafe[cp]) {\n            sb.appendBetween(x, emitted, i);\n            percentEscapeOctetTo(cp, sb);\n            emitted = x.next(i);\n          }\n          i = x.next(i);\n        }\n        new SafeUrl(\n          if (emitted \u003e String.begin) {\n            sb.appendBetween(x, emitted, end);\n            sb.toString()\n          } else {\n            x\n          }\n        )\n      }\n    }\n    let htmlAsIfQueryUrlEscaper = doPure { (): HtmlAsIfQueryUrlEscaper =\u003e new HtmlAsIfQueryUrlEscaper() };\n\n    export class HtmlCssDelegate extends HtmlDelegate {\n      public process(s: String?): String { /* TODO */ s ?? \u0022\u0022 }\n      public escaper(outer: HtmlEscaper): HtmlEscaper? { /* TODO */ outer }\n    }\n\n    export class HtmlJsDelegate extends HtmlDelegate {\n      public process(s: String?): String { /* TODO */ s ?? \u0022\u0022 }\n      public escaper(outer: HtmlEscaper): HtmlEscaper? { /* TODO */ outer }\n    }\n\n## Corner cases\n\n    test(\u0022double quotes in attribute value with inserted quotes\u0022) {\n      assert(\n          html\u0022\u0022\u0022\n            \u0022\u003cdiv id=a\u0022b\u003e\n            .text\n          == '\u003cdiv id=\u0022a\u0026#34;b\u0022\u003e');\n    }\n\n## Dependencies\n\nWe need regular expressions for finding transitions in the context propagation functions.\n\n    let { ... } = import(\u0022std/regex\u0022);\n\nThe core definitions include a lot of bundling types and also machinery like Delegate.\n\n    let { ... } = import(\u0022../core\u0022);\n\nSome URL escaping utilities from the URL codec come in handy for escaping URLs in HTML.\n\n    let { percentEscapeOctetTo } = import(\u0022../url\u0022);\n\n[js20-lexer-grammar]: https://www-archive.mozilla.org/js/language/js20-2000-07/formal/lexer-grammar\n" ], "names": [ "urlState", "toString", "urlStateStr" ], "mappings": "AA0KiB,OAGgE,EAAA,AAHhE,OAGgE,CAAA,AAHhE,IAGgE,CAAA;AAHhE,OAGgE,EAAA,AAHhE,OAGgE,CAAA,AAHhE,IAGgE,CAAA;AAHhE,gBAGgE,CAAA,AAHhE;AAGgE,CAAA;AAHhE,gBAGgE,AAHhE,qBAGgE,EAAA,AAHhE;AAGgE,KAAA;AAFpE,gBAAe,AAAL,IAAK,AAAf,CAAAA,aAAe;AAEf,cAAY,OAAM,AAAlB,CAAAC,QAAQ,EAA4D;AAAjD;AAAE,kBAAC,qBAAkB,AAAnB,EAA6C,AAH9D,EAGgE,EAAA,AAA1B,UAAW,CAAA,AAAXC,gBAAW,CAAC,IAAQ,CAAAF,aAAA,CAAI,AAA7C,EAA6C,AAAF,IAAE;AAAA,SAAE;AAD3D,iCAAA,AADC,GAAK,AAAf,CAAAA,aAAe,CACN;AADM,SAAA;AAAf,iBAAeA,aAAA,AAAf,EAAe,AAAf,CAAAA,aAAe;AAAA,SACN;AADT;AAAA;AAAA;AAAA;AAAA,4BAAAA,aAAA;AAAA;AAAA;AAAA;AAEoE" }