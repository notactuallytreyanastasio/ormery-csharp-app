{ "version": 3, "file": "csharp/ormery/src/Sql/SqlFragment.cs", "sources": [ "-work/src/sql/model.temper.md" ], "sourcesContent": [ "# SQL Data Model\n\nWe build an abstract model that can be rendered to different dialects.\n\n## SqlFragment\n\nThe fragment class supports semi-structured raw SQL text and data values, which\nthen can be escaped differently for different dbs. And while called a\n\u0022fragment\u0022, an instance can also represent a full statement.\n\n    export class SqlFragment(\n      public parts: List\u003cSqlPart\u003e,\n    ) {\n\n### toSource\n\nFreeze this to string source content marked as safe SQL.\n\nTODO Make different forms for different dialects.\n\n      public toSource(): SqlSource {\n        new SqlSource(toString())\n      }\n\n### toString\n\nTODO Make different forms for different dialects.\n\n      public toString(): String {\n        let builder = new StringBuilder();\n        for (var i = 0; i \u003c parts.length; ++i) {\n          parts[i].formatTo(builder);\n        }\n        builder.toString()\n      }\n\n    }\n\n## SqlPart\n\nEach part of a SQL fragment is either raw known-safe SQL source or else a value\nneeding escaped and/or represented properly for a particular DB dialect.\n\nTODO If we represent SQL syntax in a structured way, we could perhaps do more.\n\n    export sealed interface SqlPart {\n\n### formatTo\n\nEnables using a single StringBuilder across multiple parts for efficiency.\n\nTODO Different dialects.\n\n      public formatTo(builder: StringBuilder): Void;\n\n    }\n\n### SqlSource\n\n`SqlSource` represents known-safe SQL source code that doesn't need escaped. This\noften originates from the raw string content in `sql`-tagged strings. For\nexample, in `sql\u0022select p.name from person p where p.id = \u0024{id}\u0022`, all except\nthe `\u0024{id}` interpolation becomes a `SqlSource` instance.\n\n    export class SqlSource(public source: String) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(source);\n      }\n\n    }\n\n### SqlBoolean\n\n    export class SqlBoolean(public value: Boolean) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(if (value) { \u0022TRUE\u0022 } else { \u0022FALSE\u0022 });\n      }\n\n    }\n\n### SqlDate\n\n    export class SqlDate(public value: Date) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(\u0022'\u0022);\n        let s = value.toString();\n        for (let c of s) {\n          if (c == char'\\'') {\n            builder.append(\u0022''\u0022);\n          } else {\n            builder.appendCodePoint(c) orelse panic();\n          }\n        }\n        builder.append(\u0022'\u0022);\n      }\n\n    }\n\n### SqlFloat64\n\n    export class SqlFloat64(public value: Float64) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(value.toString());\n      }\n\n    }\n\n### SqlInt32\n\n    export class SqlInt32(public value: Int32) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(value.toString());\n      }\n\n    }\n\n### SqlInt64\n\n    export class SqlInt64(public value: Int64) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(value.toString());\n      }\n\n    }\n\n### SqlString\n\n`SqlString` represents text data that needs escaped.\n\n    export class SqlString(public value: String) extends SqlPart {\n\n### formatTo\n\n      public formatTo(builder: StringBuilder): Void {\n        builder.append(\u0022'\u0022);\n        for (let c of value) {\n          if (c == char'\\'') {\n            builder.append(\u0022''\u0022);\n          } else {\n            builder.appendCodePoint(c) orelse panic();\n          }\n        }\n        builder.append(\u0022'\u0022);\n      }\n\n    }\n" ], "names": [ "parts", "toSource", "toString", "t#1186", "builder", "i", "formatTo" ], "mappings": "AAUiB,OAwBV,EAAA,AAxBU,OAwBV,CAAA,AAxBU,WAwBV,CAAA,AAxBU,OAwBV,CAAA;AAxBU,OAwBV,EAAA,AAxBU,OAwBV,CAAA,AAxBU,IAwBV,CAAA;AAxBU,gBAwBV,CAAA,AAxBU;AAwBV,CAAA;AAxBU,gBAwBV,AAxBU;AAwBV,KAAA;AAvBM,gBAAoB,AADhB,EAwBV,EAAA,AAvBa,aAAa,CAAA,AAAb,QAAa,CAAA,AAApB,CAAAA,UAAoB;AASpB,cAAY,UAAS,AAArB,CAAAC,QAAQ,EAEd;AAF4B;AAC3B,gCAAyB,CAAA,AAAX,IAAQ,CAAA,AAARC,QAAQ,EAAE,CAAC;AAAA;AAOpB,cAAY,OAAM,AAAlB,CAAAA,QAAQ,EAMd;AANyB;AAEJ,eAAY,AAAZ,CAAAC,QAAY,CAAA;AApBvB,aAwBV,EAAA,AALK,aAAO,AAAP,CAAAC,YAAO,EAAG,IAAA,AAnBL,EAwBV,EAAA,AALe,aAAmB;AACxB,eAAC,AAAD,CAAAC,MAAC,EAAG,EAAC,CAAA;AAAd;AAAuC,aAAA;AAAnB,gBAAAF,QAAA,EAAY,AAAZ,KAAK,CAAAH,UAAA,CAAO,MAAA;AAAhB,qBAAgB,CAAA,AAAhBK,MAAC,AAAD,EAAgB,AAAZ,CAAAF,QAAY,SACrB;AAAT,oBAAK,CAAAH,UAAA,CAACK,MAAC,CAAC,CAACC,QAAQ,CAACF,YAAO,CAAC,CAAA;AADQ,gBAAAC,MAAC,AAAH,EAAG,AAAD,CAAAA,MAAC;AAAA;AAGrC,mBAAAD,YAAO,CAAW;AAAA,SACnB;AAtBD,2BAAA,AAFW,CAwBV,EAAA,AAvBa,aAAa,CAAA,AAAb,QAAa,CAAA,AAApB,CAAAJ,UAAoB,CAC3B;AAD2B,SAAA;AAApB,iBAAoBA,UAAA,AAApB,EAAoB,AAApB,CAAAA,UAAoB;AAAA,SAC3B;AADO,cAAA,AADI,EAwBV,EAAA,AAvBM;AAAA;AAAA;AAAA;AAAA,4BAAAA,UAAA;AAAA;AAAA;AAAA;AAuBN" }