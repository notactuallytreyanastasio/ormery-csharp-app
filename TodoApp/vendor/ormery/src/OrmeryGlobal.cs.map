{ "version": 3, "file": "csharp/ormery/src/OrmeryGlobal.cs", "sourceRoot": "-work/src/", "sources": [ "demo-controller.temper.md", "ormery.temper.md", "syntax-highlighter.temper.md" ], "sourcesContent": [ "# Demo Controller\n\nBusiness logic for the ORMery tutorial demo, written in Temper.\n\n## DemoController Class\n\n    export class DemoController(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var queryCount: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        queryCount = 0;\n      }\n\n      // Get total record count\n      public getRecordCount(): Int {\n        store.count(schema.tableName)\n      }\n\n      // Get count of adults (age \u003e= 18)\n      public getAdultCount(): Int {\n        new Query(schema, store)\n          .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n          .all()\n          .length\n      }\n\n      // Get number of queries run\n      public getQueryCount(): Int {\n        queryCount\n      }\n\n      // Increment query counter\n      private incrementQueryCount(): Void {\n        queryCount = queryCount + 1;\n      }\n\n      // Format a list of records as text\n      private formatRecords(records: List\u003cRecord\u003e): String {\n        let lines = records.map { (record: Record): String =\u003e\n          \u0022  \u0024{record.describe()}\u0022\n        };\n        lines.join(\u0022\\n\u0022) { (s: String): String =\u003e s }\n      }\n\n      // Demo 1: Get all users\n      public runDemo1(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store).all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 1: All Users ===\\n\\nQuery: new Query(userSchema, store).all()\\n\\nResults:\\n\u0024{formatted}\\n\\nTotal: \u0024{results.length} records\u0022\n      }\n\n      // Demo 2: Filter adults (age \u003e= 18)\n      public runDemo2(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store)\n          .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n          .all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 2: Filter Adults ===\\n\\nQuery: new Query(userSchema, store)\\n  .where(\\\u0022age\\\u0022, \\\u0022\u003e=\\\u0022, \\\u002218\\\u0022)\\n  .all()\\n\\nResults:\\n\u0024{formatted}\\n\\nTotal: \u0024{results.length} adults found\u0022\n      }\n\n      // Demo 3: Sort by age descending\n      public runDemo3(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store)\n          .orderBy(\u0022age\u0022, \u0022desc\u0022)\n          .all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 3: Sort by Age (Descending) ===\\n\\nQuery: new Query(userSchema, store)\\n  .orderBy(\\\u0022age\\\u0022, \\\u0022desc\\\u0022)\\n  .all()\\n\\nResults (ordered by age, oldest first):\\n\u0024{formatted}\u0022\n      }\n\n      // Demo 4: Pagination\n      public runDemo4(): String {\n        incrementQueryCount();\n        let page1 = new Query(schema, store)\n          .orderBy(\u0022id\u0022, \u0022asc\u0022)\n          .limit(2)\n          .all();\n        let page2 = new Query(schema, store)\n          .orderBy(\u0022id\u0022, \u0022asc\u0022)\n          .offset(2)\n          .limit(2)\n          .all();\n        let formatted1 = formatRecords(page1);\n        let formatted2 = formatRecords(page2);\n        \u0022=== Demo 4: Pagination ===\\n\\nPage 1: .orderBy(\\\u0022id\\\u0022, \\\u0022asc\\\u0022).limit(2)\\n\\n\u0024{formatted1}\\n\\nPage 2: .orderBy(\\\u0022id\\\u0022, \\\u0022asc\\\u0022).offset(2).limit(2)\\n\\n\u0024{formatted2}\u0022\n      }\n\n      // Demo 5: Complex query with all features\n      public runDemo5(): String {\n        incrementQueryCount();\n        let results = new Query(schema, store)\n          .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n          .where(\u0022email\u0022, \u0022!=\u0022, \u0022\u0022)\n          .orderBy(\u0022age\u0022, \u0022desc\u0022)\n          .select([\u0022name\u0022, \u0022age\u0022])\n          .limit(2)\n          .all();\n        let formatted = formatRecords(results);\n        \u0022=== Demo 5: Complex Query ===\\n\\nQuery: new Query(userSchema, store)\\n  .where(\\\u0022age\\\u0022, \\\u0022\u003e=\\\u0022, \\\u002218\\\u0022)\\n  .where(\\\u0022email\\\u0022, \\\u0022!=\\\u0022, \\\u0022\\\u0022)\\n  .orderBy(\\\u0022age\\\u0022, \\\u0022desc\\\u0022)\\n  .select([\\\u0022name\\\u0022, \\\u0022age\\\u0022])\\n  .limit(2)\\n  .all()\\n\\nResults (adults with email, showing name/age only, oldest first, max 2):\\n\u0024{formatted}\u0022\n      }\n    }\n", "# ORMery - All-in-One Demo\n\nA simplified version of Ecto in Temper, using secure-composition for\ninjection-proof SQL generation.\n\n    let { sql, SqlFragment, SqlBuilder } = import(\u0022./sql\u0022);\n\n## Field and Schema\n\n    export class Field(\n      public name: String,\n      public fieldType: String,\n      public primaryKey: Boolean,\n      public nullable: Boolean,\n    ) {\n      public get description(): String {\n        let pk = if (primaryKey) { \u0022 (PK)\u0022 } else { \u0022\u0022 };\n        let null = if (nullable) { \u0022 (nullable)\u0022 } else { \u0022\u0022 };\n        \u0022\u0024{name}: \u0024{fieldType}\u0024{pk}\u0024{null}\u0022\n      }\n    }\n\n    export class Schema(\n      public tableName: String,\n      public fields: List\u003cField\u003e,\n    ) {\n      public getField(name: String): Field throws Bubble {\n        for (let field of fields) {\n          if (field.name == name) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public hasField(name: String): Boolean {\n        for (let field of fields) {\n          if (field.name == name) {\n            return true;\n          }\n        }\n        false\n      }\n\n      public get primaryKeyField(): Field throws Bubble {\n        for (let field of fields) {\n          if (field.primaryKey) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public get fieldNames(): List\u003cString\u003e {\n        fields.map { (f: Field): String =\u003e f.name }\n      }\n\n      public describe(): String {\n        let header = \u0022Schema: \u0024{tableName}\\n\u0022;\n        let fieldList = fields\n          .map { (f: Field): String =\u003e \u0022  - \u0024{f.description}\u0022 }\n          .join(\u0022\\n\u0022) { (s: String): String =\u003e s };\n        \u0022\u0024{header}\u0024{fieldList}\u0022\n      }\n    }\n\n    export let field(\n      name: String,\n      fieldType: String,\n      primaryKey: Boolean,\n      nullable: Boolean,\n    ): Field {\n      new Field(name, fieldType, primaryKey, nullable)\n    }\n\n### Identifier validation\n\nOnly allow safe SQL identifier characters: `a-z`, `A-Z`, `0-9`, `_`.\nThis closes the table name backdoor where `schema()` accepted arbitrary\nstrings that passed through `safeSql()` → `appendSafe()` unescaped.\n\n    export let isValidIdentifier(name: String): Boolean {\n      if (name.isEmpty) { return false; }\n      for (let c of name) {\n        if (c != char'_') {\n          if (c \u003e= char'a') {\n            if (c \u003e char'z') { return false; }\n          } else if (c \u003e= char'A') {\n            if (c \u003e char'Z') { return false; }\n          } else if (c \u003e= char'0') {\n            if (c \u003e char'9') { return false; }\n          } else {\n            return false;\n          }\n        }\n      }\n      true\n    }\n\n    export let schema(tableName: String, fields: List\u003cField\u003e): Schema {\n      if (!isValidIdentifier(tableName)) { panic(); }\n      let idField = new Field(\u0022id\u0022, \u0022Int\u0022, true, false);\n      let allFields = new ListBuilder\u003cField\u003e();\n      allFields.add(idField);\n      allFields.addAll(fields);\n      new Schema(tableName, allFields.toList())\n    }\n\n## Record and Store\n\n    export class Record(\n      public data: Map\u003cString, String\u003e,\n    ) {\n      public get(field: String): String throws Bubble {\n        data.get(field)\n      }\n\n      public getOr(field: String, fallback: String): String {\n        data.getOr(field, fallback)\n      }\n\n      public has(field: String): Boolean {\n        data.has(field)\n      }\n\n      public get id(): Int throws Bubble {\n        let idStr = data.get(\u0022id\u0022);\n        idStr.toInt32() orelse bubble()\n      }\n\n      public describe(): String {\n        let pairs = data.toListWith { (k: String, v: String): String =\u003e\n          \u0022\u0024{k}: \u0024{v}\u0022\n        };\n        pairs.join(\u0022, \u0022) { (s: String): String =\u003e s }\n      }\n    }\n\n    export class InMemoryStore() {\n      private var tables: MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e;\n      private var nextIds: MapBuilder\u003cString, Int\u003e;\n\n      public constructor() {\n        tables = new MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e();\n        nextIds = new MapBuilder\u003cString, Int\u003e();\n      }\n\n      private ensureTable(tableName: String): Void {\n        if (!tables.has(tableName)) {\n          tables.set(tableName, new ListBuilder\u003cRecord\u003e());\n          nextIds.set(tableName, 1);\n        }\n      }\n\n      public insert(tableName: String, data: Map\u003cString, String\u003e): Record {\n        ensureTable(tableName);\n        let id = nextIds.getOr(tableName, 1);\n        nextIds.set(tableName, id + 1);\n\n        let dataBuilder = data.toMapBuilder();\n        dataBuilder.set(\u0022id\u0022, id.toString());\n        let record = new Record(dataBuilder.toMap());\n\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.add(record);\n        record\n      }\n\n      public all(tableName: String): List\u003cRecord\u003e {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.toList()\n      }\n\n      public get(tableName: String, id: Int): Record throws Bubble {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n\n        for (let record of table.toList()) {\n          let recordId = record.id orelse bubble();\n          if (recordId == id) {\n            return record;\n          }\n        }\n        bubble()\n      }\n\n      public count(tableName: String): Int {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.length\n      }\n    }\n\n## Query Builder\n\n    export class WhereClause(\n      public field: String,\n      public operator: String,\n      public value: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{operator} \u0024{value}\u0022\n      }\n    }\n\n    export class OrderClause(\n      public field: String,\n      public direction: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{direction}\u0022\n      }\n    }\n\n    export class Query(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var whereClauses: ListBuilder\u003cWhereClause\u003e;\n      private var selectFields: List\u003cString\u003e;\n      private var orderByClauses: ListBuilder\u003cOrderClause\u003e;\n      private var limitValue: Int;\n      private var offsetValue: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        whereClauses = new ListBuilder\u003cWhereClause\u003e();\n        selectFields = [];\n        orderByClauses = new ListBuilder\u003cOrderClause\u003e();\n        limitValue = -1;\n        offsetValue = 0;\n      }\n\n      public where(field: String, operator: String, value: String): Query {\n        whereClauses.add(new WhereClause(field, operator, value));\n        this\n      }\n\n      public select(fields: List\u003cString\u003e): Query {\n        selectFields = fields;\n        this\n      }\n\n      public orderBy(field: String, direction: String): Query {\n        orderByClauses.add(new OrderClause(field, direction));\n        this\n      }\n\n      public limit(n: Int): Query {\n        limitValue = if (n \u003c 0) { 0 } else { n };\n        this\n      }\n\n      public offset(n: Int): Query {\n        offsetValue = n;\n        this\n      }\n\n      private matchesWhere(record: Record): Boolean {\n        for (let clause of whereClauses.toList()) {\n          let recordValue = record.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            return false;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let matches = when (fieldType) {\n            \u0022Int\u0022 -\u003e compareInt(recordValue, clause.operator, clause.value);\n            \u0022String\u0022 -\u003e compareString(recordValue, clause.operator, clause.value);\n            else -\u003e false;\n          };\n          if (!matches) {\n            return false;\n          }\n        }\n        true\n      }\n\n      private projectRecord(record: Record): Record {\n        if (selectFields.length == 0) {\n          return record;\n        }\n        let builder = new MapBuilder\u003cString, String\u003e();\n        for (let fieldName of selectFields) {\n          let value = record.getOr(fieldName, \u0022\u0022);\n          builder.set(fieldName, value);\n        }\n        new Record(builder.toMap())\n      }\n\n      private compareRecords(a: Record, b: Record, orderClauses: List\u003cOrderClause\u003e): Int {\n        for (let clause of orderClauses) {\n          let aVal = a.getOr(clause.field, \u0022\u0022);\n          let bVal = b.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            continue;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let cmp = when (fieldType) {\n            \u0022Int\u0022 -\u003e do {\n              let aInt = aVal.toInt32() orelse 0;\n              let bInt = bVal.toInt32() orelse 0;\n              aInt \u003c=\u003e bInt\n            };\n            \u0022String\u0022 -\u003e aVal \u003c=\u003e bVal;\n            else -\u003e 0;\n          };\n          if (cmp != 0) {\n            return if (clause.direction == \u0022desc\u0022) { -cmp } else { cmp };\n          }\n        }\n        0\n      }\n\n      public all(): List\u003cRecord\u003e {\n        let allRecords = store.all(schema.tableName);\n        let filtered = allRecords.filter { (r: Record): Boolean =\u003e\n          matchesWhere(r)\n        };\n        let sorted = if (orderByClauses.length \u003e 0) {\n          let clauses = orderByClauses.toList();\n          filtered.sorted { (a: Record, b: Record): Int =\u003e\n            compareRecords(a, b, clauses)\n          }\n        } else {\n          filtered\n        };\n        let sliced = if (limitValue \u003e= 0) {\n          let start = offsetValue;\n          let end = offsetValue + limitValue;\n          sorted.slice(start, end)\n        } else if (offsetValue \u003e 0) {\n          sorted.slice(offsetValue, sorted.length)\n        } else {\n          sorted\n        };\n        sliced.map { (r: Record): Record =\u003e projectRecord(r) }\n      }\n\n      public toSql(): SqlFragment {\n        toSqlQuery(schema, selectFields, whereClauses.toList(),\n                   orderByClauses.toList(), limitValue, offsetValue)\n      }\n    }\n\n    let compareInt(recordValue: String, operator: String, clauseValue: String): Boolean {\n      let rv = recordValue.toInt32() orelse 0;\n      let cv = clauseValue.toInt32() orelse 0;\n      if (clauseValue != cv.toString()) { return false; }\n      when (operator) {\n        \u0022==\u0022 -\u003e rv == cv;\n        \u0022!=\u0022 -\u003e rv != cv;\n        \u0022\u003e\u0022 -\u003e rv \u003e cv;\n        \u0022\u003c\u0022 -\u003e rv \u003c cv;\n        \u0022\u003e=\u0022 -\u003e rv \u003e= cv;\n        \u0022\u003c=\u0022 -\u003e rv \u003c= cv;\n        else -\u003e false;\n      }\n    }\n\n    let compareString(recordValue: String, operator: String, clauseValue: String): Boolean {\n      when (operator) {\n        \u0022==\u0022 -\u003e recordValue == clauseValue;\n        \u0022!=\u0022 -\u003e recordValue != clauseValue;\n        \u0022\u003e\u0022 -\u003e recordValue \u003e clauseValue;\n        \u0022\u003c\u0022 -\u003e recordValue \u003c clauseValue;\n        \u0022\u003e=\u0022 -\u003e recordValue \u003e= clauseValue;\n        \u0022\u003c=\u0022 -\u003e recordValue \u003c= clauseValue;\n        else -\u003e false;\n      }\n    }\n\n## SQL Generation\n\nPure functions that produce `SqlFragment` from query state using\nsecure-composition's `sql\u0022...\u0022` tagged strings. Interpolated values are\nautomatically escaped by type. Trusted SQL identifiers (table names, column\nnames, operators) are composed via fragment nesting.\n\n### Operator validation\n\nOnly allow known SQL comparison operators. Returns the operator if valid,\nor `=` as a safe fallback.\n\n    let validOperator(op: String): String {\n      when (op) {\n        \u0022=\u0022 -\u003e \u0022=\u0022;\n        \u0022==\u0022 -\u003e \u0022=\u0022;\n        \u0022!=\u0022 -\u003e \u0022!=\u0022;\n        \u0022\u003c\u003e\u0022 -\u003e \u0022\u003c\u003e\u0022;\n        \u0022\u003e\u0022 -\u003e \u0022\u003e\u0022;\n        \u0022\u003c\u0022 -\u003e \u0022\u003c\u0022;\n        \u0022\u003e=\u0022 -\u003e \u0022\u003e=\u0022;\n        \u0022\u003c=\u0022 -\u003e \u0022\u003c=\u0022;\n        else -\u003e \u0022=\u0022;\n      }\n    }\n\n### Trusted identifier fragment\n\nWraps a trusted identifier (table name, column name, operator) as a\n`SqlFragment`. These come from schema definitions, not user input.\n\n    let safeSql(trusted: String): SqlFragment {\n      let b = new SqlBuilder();\n      b.appendSafe(trusted);\n      b.accumulated\n    }\n\n### Column list helper\n\nBuilds the SELECT column list. If no fields specified, returns `*`.\n\n    let columnListSql(selectFields: List\u003cString\u003e): SqlFragment {\n      if (selectFields.length == 0) {\n        sql\u0022*\u0022\n      } else {\n        let first = safeSql(selectFields[0]);\n        var result = sql\u0022\u0024{first}\u0022;\n        for (var i = 1; i \u003c selectFields.length; i = i + 1) {\n          let col = safeSql(selectFields[i]);\n          result = sql\u0022\u0024{result}, \u0024{col}\u0022;\n        }\n        result\n      }\n    }\n\n### WHERE clause helper\n\nBuilds a single WHERE condition. The value is untrusted user input —\n`sql\u0022...\u0022` escapes it by type automatically.\n\n    let whereConditionSql(clause: WhereClause, schema: Schema): SqlFragment {\n      let col = safeSql(clause.field);\n      let op = safeSql(validOperator(clause.operator));\n      let fieldInfo = schema.getField(clause.field) orelse panic();\n      if (fieldInfo.fieldType == \u0022Int\u0022) {\n        let intVal = clause.value.toInt32() orelse 0;\n        if (clause.value != intVal.toString()) {\n          sql\u00221 = 0\u0022\n        } else {\n          sql\u0022\u0024{col} \u0024{op} \u0024{intVal}\u0022\n        }\n      } else {\n        let strVal = clause.value;\n        sql\u0022\u0024{col} \u0024{op} \u0024{strVal}\u0022\n      }\n    }\n\n### ORDER BY clause helper\n\n    let orderBySql(clauses: List\u003cOrderClause\u003e): SqlFragment {\n      let first = safeSql(clauses[0].field);\n      let firstDir = if (clauses[0].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n      var result = sql\u0022\u0024{first}\u0024{firstDir}\u0022;\n      for (var i = 1; i \u003c clauses.length; i = i + 1) {\n        let col = safeSql(clauses[i].field);\n        let dir = if (clauses[i].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n        result = sql\u0022\u0024{result}, \u0024{col}\u0024{dir}\u0022;\n      }\n      result\n    }\n\n### Full SELECT query builder\n\nAssembles a complete SELECT statement from parts. This is the main pure\nfunction: it takes query state in, returns `SqlFragment` out. Field names\nare validated against the schema — only declared fields pass through\n`safeSql`. Unknown fields are silently dropped, closing the confused deputy\nvector where user-controlled strings could reach `appendSafe`.\n\n    export let toSqlQuery(\n      schema: Schema,\n      selectFields: List\u003cString\u003e,\n      whereClauses: List\u003cWhereClause\u003e,\n      orderClauses: List\u003cOrderClause\u003e,\n      limitValue: Int,\n      offsetValue: Int,\n    ): SqlFragment {\n      let validSelect = selectFields.filter { (f: String): Boolean =\u003e\n        schema.hasField(f)\n      };\n      let validWhere = whereClauses.filter { (c: WhereClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let validOrder = orderClauses.filter { (c: OrderClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let table = safeSql(schema.tableName);\n      let cols = columnListSql(validSelect);\n      var result = sql\u0022SELECT \u0024{cols} FROM \u0024{table}\u0022;\n      if (validWhere.length \u003e 0) {\n        var conditions = whereConditionSql(validWhere[0], schema);\n        for (var i = 1; i \u003c validWhere.length; i = i + 1) {\n          let next = whereConditionSql(validWhere[i], schema);\n          conditions = sql\u0022\u0024{conditions} AND \u0024{next}\u0022;\n        }\n        result = sql\u0022\u0024{result} WHERE \u0024{conditions}\u0022;\n      }\n      if (validOrder.length \u003e 0) {\n        let ordering = orderBySql(validOrder);\n        result = sql\u0022\u0024{result} ORDER BY \u0024{ordering}\u0022;\n      }\n      if (limitValue \u003e= 0) {\n        result = sql\u0022\u0024{result} LIMIT \u0024{limitValue}\u0022;\n      }\n      if (offsetValue \u003e 0) {\n        result = sql\u0022\u0024{result} OFFSET \u0024{offsetValue}\u0022;\n      }\n      result\n    }\n\n### INSERT statement builder\n\nGenerates an INSERT statement from a schema and a map of field values.\nField names come from the schema (trusted). Values are escaped via\n`sql\u0022...\u0022` by type.\n\n    export let toInsertSql(\n      schema: Schema,\n      values: Map\u003cString, String\u003e,\n    ): SqlFragment {\n      let table = safeSql(schema.tableName);\n      let fieldList = schema.fields.filter { (f: Field): Boolean =\u003e\n        values.has(f.name)\n      };\n      if (fieldList.length == 0) {\n        return sql\u0022\u0022;\n      }\n      let colNames = columnListSql(\n        fieldList.map { (f: Field): String =\u003e f.name }\n      );\n      let firstVal = values.getOr(fieldList[0].name, \u0022\u0022);\n      var vals = if (fieldList[0].fieldType == \u0022Int\u0022) {\n        let iv = firstVal.toInt32() orelse 0;\n        sql\u0022\u0024{iv}\u0022\n      } else {\n        sql\u0022\u0024{firstVal}\u0022\n      };\n      for (var i = 1; i \u003c fieldList.length; i = i + 1) {\n        let val = values.getOr(fieldList[i].name, \u0022\u0022);\n        if (fieldList[i].fieldType == \u0022Int\u0022) {\n          let iv = val.toInt32() orelse 0;\n          vals = sql\u0022\u0024{vals}, \u0024{iv}\u0022;\n        } else {\n          vals = sql\u0022\u0024{vals}, \u0024{val}\u0022;\n        }\n      }\n      sql\u0022INSERT INTO \u0024{table} (\u0024{colNames}) VALUES (\u0024{vals})\u0022\n    }\n\n## SQL Generation Tests\n\n### Basic SELECT\n\n    test(\u0022toSql: select all\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n### SELECT with specific columns\n\n    test(\u0022toSql: select columns\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).select([\u0022name\u0022, \u0022age\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name, age FROM users\u0022);\n    }\n\n### WHERE with string value\n\n    test(\u0022toSql: where string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### WHERE with integer value\n\n    test(\u0022toSql: where int\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18\u0022);\n    }\n\n### SQL injection protection\n\nThe Bobby Tables attack string is safely escaped — single quotes are doubled.\n\n    test(\u0022toSql: SQL injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, bobby);\n      let result = q.toSql().toString();\n      assert(result == \u0022SELECT * FROM users WHERE name = 'Robert''); DROP TABLE users;--'\u0022);\n    }\n\n### Operator normalization\n\nThe `==` operator from the in-memory query API is normalized to SQL `=`.\n\n    test(\u0022toSql: operator normalization\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022==\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Invalid operator fallback\n\nUnknown operators fall back to `=` for safety.\n\n    test(\u0022toSql: invalid operator fallback\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022LIKE\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Multiple WHERE clauses\n\n    test(\u0022toSql: multiple where\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .where(\u0022age\u0022, \u0022\u003c\u0022, \u002230\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18 AND age \u003c 30\u0022);\n    }\n\n### ORDER BY\n\n    test(\u0022toSql: order by\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022name\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY name ASC\u0022);\n    }\n\n### ORDER BY descending\n\n    test(\u0022toSql: order by desc\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022age\u0022, \u0022desc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY age DESC\u0022);\n    }\n\n### LIMIT and OFFSET\n\n    test(\u0022toSql: limit\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(10);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 10\u0022);\n    }\n\n    test(\u0022toSql: offset\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).offset(5);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users OFFSET 5\u0022);\n    }\n\n### Complex query\n\n    test(\u0022toSql: complex query\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10)\n        .offset(20);\n      assert(q.toSql().toString() ==\n        \u0022SELECT name, age FROM users WHERE age \u003e= 18 ORDER BY age DESC LIMIT 10 OFFSET 20\u0022);\n    }\n\n### Unicode in values\n\n    test(\u0022toSql: unicode escaping\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Hello 世界\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Hello 世界'\u0022);\n    }\n\n### Embedded quotes in values\n\n    test(\u0022toSql: embedded quotes\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022O'Brien\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'O''Brien'\u0022);\n    }\n\n### Empty string value\n\n    test(\u0022toSql: empty string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = ''\u0022);\n    }\n\n### INSERT statement\n\n    test(\u0022toInsertSql: basic insert\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022INSERT INTO users (name, age) VALUES ('Alice', 25)\u0022);\n    }\n\n### INSERT with injection protection\n\n    test(\u0022toInsertSql: injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Robert'); DROP TABLE users;--\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() ==\n        \u0022INSERT INTO users (name) VALUES ('Robert''); DROP TABLE users;--')\u0022);\n    }\n\n### toSqlQuery as standalone pure function\n\n    test(\u0022toSqlQuery: standalone\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let result = toSqlQuery(\n        s, [\u0022name\u0022], [new WhereClause(\u0022age\u0022, \u0022\u003e\u0022, \u002221\u0022)],\n        [new OrderClause(\u0022name\u0022, \u0022asc\u0022)], 5, 0,\n      );\n      assert(result.toString() ==\n        \u0022SELECT name FROM users WHERE age \u003e 21 ORDER BY name ASC LIMIT 5\u0022);\n    }\n\n### Adversarial field name protection\n\nField names not in the schema are silently dropped from SQL generation.\nThis prevents confused deputy attacks where user-controlled strings\ncould reach `appendSafe` through field name positions.\n\n    test(\u0022toSql: adversarial field name blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u00221=1; DROP TABLE users; --\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial select column blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u00221; DROP TABLE users\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial order by blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .orderBy(\u00221; DROP TABLE users\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n## Security Audit Fix Tests\n\n### Fix #1: Table name validation\n\n    test(\u0022isValidIdentifier: valid names\u0022) {\n      assert(isValidIdentifier(\u0022users\u0022));\n      assert(isValidIdentifier(\u0022user_table\u0022));\n      assert(isValidIdentifier(\u0022Table1\u0022));\n      assert(isValidIdentifier(\u0022_private\u0022));\n      assert(isValidIdentifier(\u0022a\u0022));\n    }\n\n    test(\u0022isValidIdentifier: invalid names\u0022) {\n      assert(!isValidIdentifier(\u0022\u0022));\n      assert(!isValidIdentifier(\u0022users; DROP TABLE\u0022));\n      assert(!isValidIdentifier(\u0022users--\u0022));\n      assert(!isValidIdentifier(\u0022ta ble\u0022));\n      assert(!isValidIdentifier(\u0022table.name\u0022));\n      assert(!isValidIdentifier(\u0022Robert'); DROP TABLE users;--\u0022));\n    }\n\n### Fix #3: Non-numeric value for Int field\n\n    test(\u0022toSql: non-numeric Int value produces always-false\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE 1 = 0\u0022);\n    }\n\n    test(\u0022in-memory: non-numeric Int value matches nothing\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u00220\u0022),\n      ]));\n      let results = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022).all();\n      assert(results.length == 0);\n    }\n\n### Fix #5: LIMIT zero and negative\n\n    test(\u0022toSql: limit zero emits LIMIT 0\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(0);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 0\u0022);\n    }\n\n    test(\u0022in-memory: limit zero returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(0).all();\n      assert(results.length == 0);\n    }\n\n    test(\u0022in-memory: negative limit clamped to zero\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(-5).all();\n      assert(results.length == 0);\n    }\n\n### Fix #6: Empty insert safety\n\n    test(\u0022toInsertSql: no matching fields returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022nonexistent\u0022, \u0022value\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022\u0022);\n    }\n\n## Demo\n\n    export let main(): Void {\n      console.log(\u0022=== ORMery Demo ===\\n\u0022);\n\n      let userFields = [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n        field(\u0022email\u0022, \u0022String\u0022, false, true),\n      ];\n      let userSchema = schema(\u0022users\u0022, userFields);\n\n      console.log(userSchema.describe());\n      console.log(\u0022\u0022);\n\n      let store = new InMemoryStore();\n\n      let rec1 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n        new Pair(\u0022email\u0022, \u0022alice@example.com\u0022),\n      ]));\n\n      let rec2 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Bob\u0022),\n        new Pair(\u0022age\u0022, \u002230\u0022),\n        new Pair(\u0022email\u0022, \u0022bob@example.com\u0022),\n      ]));\n\n      let rec3 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Charlie\u0022),\n        new Pair(\u0022age\u0022, \u002217\u0022),\n        new Pair(\u0022email\u0022, \u0022charlie@example.com\u0022),\n      ]));\n\n      console.log(\u0022Inserted 3 users:\u0022);\n      console.log(\u0022  \u0024{rec1.describe()}\u0022);\n      console.log(\u0022  \u0024{rec2.describe()}\u0022);\n      console.log(\u0022  \u0024{rec3.describe()}\u0022);\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== In-Memory Queries ===\\n\u0022);\n\n      console.log(\u0022All users:\u0022);\n      let allUsers = new Query(userSchema, store).all();\n      for (let u of allUsers) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022Adults (age \u003e= 18):\u0022);\n      let adults = new Query(userSchema, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .all();\n      for (let u of adults) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== SQL Generation (secure-composition) ===\\n\u0022);\n\n      let q1 = new Query(userSchema, store);\n      console.log(\u0022SELECT all: \u0024{q1.toSql().toString()}\u0022);\n\n      let q2 = new Query(userSchema, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10);\n      console.log(\u0022Complex:    \u0024{q2.toSql().toString()}\u0022);\n\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q3 = new Query(userSchema, store)\n        .where(\u0022name\u0022, \u0022=\u0022, bobby);\n      console.log(\u0022Injection:  \u0024{q3.toSql().toString()}\u0022);\n\n      let insertVals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022O'Malley\u0022),\n        new Pair(\u0022age\u0022, \u002242\u0022),\n      ]);\n      console.log(\u0022INSERT:     \u0024{toInsertSql(userSchema, insertVals).toString()}\u0022);\n\n      console.log(\u0022\\n=== Demo Complete ===\u0022);\n    }\n", "# Temper Syntax Highlighter\n\nA syntax highlighter for Temper code, written in Temper. Uses\nsecure-composition's `html\u0022...\u0022` tagged strings for contextual\nauto-escaping — values interpolated into element content are\nHTML-entity-encoded automatically.\n\n    let { html, SafeHtml } = import(\u0022./html\u0022);\n\n## Token Types\n\n    export class TokenType(public name: String) {\n      public get isKeyword(): Boolean { name == \u0022keyword\u0022 }\n      public get isType(): Boolean { name == \u0022type\u0022 }\n      public get isString(): Boolean { name == \u0022string\u0022 }\n      public get isNumber(): Boolean { name == \u0022number\u0022 }\n      public get isComment(): Boolean { name == \u0022comment\u0022 }\n      public get isOperator(): Boolean { name == \u0022operator\u0022 }\n      public get isIdentifier(): Boolean { name == \u0022identifier\u0022 }\n    }\n\n## Token\n\n    export class Token(\n      public tokenType: TokenType,\n      public value: String,\n    ) {\n      public cssClass(): String {\n        let name = tokenType.name;\n        when (name) {\n          \u0022keyword\u0022 -\u003e \u0022kw\u0022;\n          \u0022type\u0022 -\u003e \u0022typ\u0022;\n          \u0022string\u0022 -\u003e \u0022str\u0022;\n          \u0022number\u0022 -\u003e \u0022num\u0022;\n          \u0022comment\u0022 -\u003e \u0022cmt\u0022;\n          \u0022operator\u0022 -\u003e \u0022op\u0022;\n          else -\u003e \u0022id\u0022;\n        }\n      }\n\n      public toHtml(): SafeHtml {\n        let cls = cssClass();\n        html\u0022\u003cspan class='\u0024{cls}'\u003e\u0024{value}\u003c/span\u003e\u0022\n      }\n    }\n\n## Keyword and Type Lists\n\n    let temperKeywords: List\u003cString\u003e = [\n      \u0022if\u0022, \u0022else\u0022, \u0022for\u0022, \u0022while\u0022, \u0022do\u0022, \u0022when\u0022, \u0022break\u0022, \u0022continue\u0022, \u0022return\u0022,\n      \u0022let\u0022, \u0022var\u0022, \u0022class\u0022, \u0022export\u0022, \u0022import\u0022, \u0022public\u0022, \u0022private\u0022, \u0022protected\u0022,\n      \u0022throws\u0022, \u0022new\u0022, \u0022this\u0022, \u0022get\u0022, \u0022set\u0022, \u0022static\u0022, \u0022extends\u0022, \u0022implements\u0022,\n      \u0022true\u0022, \u0022false\u0022, \u0022null\u0022, \u0022bubble\u0022, \u0022orelse\u0022, \u0022of\u0022,\n    ];\n\n    let temperTypes: List\u003cString\u003e = [\n      \u0022String\u0022, \u0022Int\u0022, \u0022Boolean\u0022, \u0022List\u0022, \u0022Map\u0022, \u0022Bubble\u0022, \u0022Pair\u0022,\n      \u0022Float\u0022, \u0022Double\u0022, \u0022Byte\u0022, \u0022Short\u0022, \u0022Long\u0022, \u0022Char\u0022, \u0022Void\u0022,\n      \u0022Record\u0022, \u0022Schema\u0022, \u0022Field\u0022, \u0022Query\u0022, \u0022InMemoryStore\u0022,\n      \u0022ListBuilder\u0022, \u0022MapBuilder\u0022, \u0022WhereClause\u0022, \u0022OrderClause\u0022,\n    ];\n\n## Classifier\n\nClassifies a word token based on known keywords and types.\n\n    export let classifyWord(word: String): TokenType {\n      for (let kw of temperKeywords) {\n        if (kw == word) {\n          return new TokenType(\u0022keyword\u0022);\n        }\n      }\n      for (let tp of temperTypes) {\n        if (tp == word) {\n          return new TokenType(\u0022type\u0022);\n        }\n      }\n      new TokenType(\u0022identifier\u0022)\n    }\n\n## Simple Line Highlighter\n\nSince Temper's String type works with code points and StringIndex rather than\ninteger-indexed substring operations, we use a word-level approach: split each\nline by spaces and classify each token.\n\n    export let highlightWord(word: String): SafeHtml {\n      if (word == \u0022\u0022) {\n        return html\u0022\u0022;\n      }\n      let tokenType = classifyWord(word);\n      let token = new Token(tokenType, word);\n      token.toHtml()\n    }\n\n    export let highlightLine(line: String): SafeHtml {\n      let words = line.split(\u0022 \u0022);\n      if (words.length == 0) {\n        return html\u0022\u0022;\n      }\n      var result = highlightWord(words[0]);\n      for (var i = 1; i \u003c words.length; i = i + 1) {\n        let word = highlightWord(words[i]);\n        result = html\u0022\u0024{result} \u0024{word}\u0022;\n      }\n      result\n    }\n\n    export let highlightSource(source: String): SafeHtml {\n      let lines = source.split(\u0022\\n\u0022);\n      if (lines.length == 0) {\n        return html\u0022\u0022;\n      }\n      var result = highlightLine(lines[0]);\n      for (var i = 1; i \u003c lines.length; i = i + 1) {\n        let line = highlightLine(lines[i]);\n        result = html\u0022\u0024{result}\\n\u0024{line}\u0022;\n      }\n      result\n    }\n\n    export let highlightBlock(source: String): SafeHtml {\n      let highlighted = highlightSource(source);\n      html\u0022\u003cpre class='temper-code'\u003e\u003ccode\u003e\u0024{highlighted}\u003c/code\u003e\u003c/pre\u003e\u0022\n    }\n" ], "names": [ "console#737", "compareInt", "recordValue", "operator", "clauseValue", "return", "t#4028", "t#2376", "t#2378", "rv", "cv", "fn", "compareString", "safeSql", "trusted", "b", "appendSafe", "columnListSql", "selectFields", "t#4009", "t#4012", "t#4014", "t#4016", "t#4017", "t#4018", "t#4020", "t#4024", "first", "appendFragment", "result", "i", "col", "validOperator", "op", "whereConditionSql", "clause", "schema", "t#3990", "t#3993", "t#4001", "t#2320", "t#3981", "t#3983", "t#3985", "t#2316", "getField", "fieldInfo", "intVal", "appendInt32", "strVal", "appendString", "orderBySql", "clauses", "t#3961", "t#3962", "t#3967", "t#3969", "t#3973", "t#3974", "t#3975", "t#3980", "t#2303", "t#3957", "firstDir", "t#3963", "t#3966", "dir", "whereClauses", "orderClauses", "limitValue", "offsetValue", "t#3924", "t#3925", "t#3926", "t#3927", "t#3929", "t#3933", "t#3934", "t#3938", "t#3941", "t#3945", "t#3946", "t#3950", "t#3951", "t#3955", "f", "hasField", "validSelect", "c", "t#3902", "validWhere", "t#3900", "validOrder", "t#3914", "table", "cols", "t#3917", "t#3922", "conditions", "next", "ordering", "name", "fieldType", "primaryKey", "nullable", "t#3781", "this", "index", "codePoint", "tableName", "fields", "idField", "allFields", "t#3776", "values", "t#3724", "t#3726", "t#3730", "t#3733", "t#3736", "t#3740", "t#3742", "t#3743", "t#3745", "t#3746", "t#3748", "t#3752", "t#3756", "t#3757", "t#3761", "t#3762", "t#2047", "t#2058", "t#2065", "t#2066", "t#3720", "fieldList", "colNames", "firstVal", "iv", "vals", "val", "log", "userFields", "userSchema", "t#3304", "describe", "store", "rec1", "insert", "rec2", "rec3", "t#3324", "t#3326", "t#3328", "allUsers", "all", "u", "t#3298", "adults", "where", "t#3296", "q1", "t#3348", "toSql", "toString", "q2", "select", "orderBy", "limit", "t#3356", "bobby", "q3", "t#3361", "insertVals", "t#3367", "temperKeywords", "temperTypes", "word", "n", "el", "kw", "tp", "t#3275", "tokenType", "token", "toHtml", "line", "t#3263", "t#3266", "t#3267", "t#3270", "t#3274", "words", "appendSafeHtml", "source", "t#3249", "t#3252", "t#3253", "t#3256", "t#3260", "lines", "highlighted", "t#3242" ], "mappings": "A;A;A;A;A;A;A;A;A;A;A;ADMiB,uBDAA,A,IDAA,gBDAAA,aDAA,CDAA;ADsVb,uBDA4E,KDAO,ADA/E,CDAAC,eDAU,CDAc,MDAM,ADAnB,CDAAC,gBDAmB,CDAY,ODAM,ADAhB,CDAAC,aDAgB,CDAe,ODAM,ADAnB,CDAAC,gBDAmB,CDaxE;ADbmF,SDAA;ADAR,gBDAO,ADAP,CDAAC,WDAO;ADG9D,kBDAa,ADAb,CDAAC,QDAa,CDAA;ADFvB,eDAqB,ADArB,CDAAC,QDAqB;ADCrB,eDAqB,ADArB,CDAAC,QDAqB,CDAA;ADFoD;ADAA;ADC9E,uBDAE,ADAF,CDAAC,ODAmC,CDAA;ADA9B;ADAA;ADAA,wBDAAF,QDAA,EDAqB,A,IDArB,IDAqB,CDAA,ADArB,KDAqB,CDAA,ADArBL,gBDAW,CDAU,CDAA;ADArB,wBDAAO,ODAA,EDAqB,ADArB,CDAAF,QDAqB;ADAA;ADAA;ADAQ;ADAA,wBDAAE,ODAA,EDAC,ADAD,EDAC;ADAA;ADCnC,uBDAE,ADAF,CDAAC,ODAmC,CDAA;ADA9B;ADAA;ADAA,wBDAAF,QDAA,EDAqB,A,IDArB,IDAqB,CDAA,ADArB,KDAqB,CDAA,ADArBJ,gBDAW,CDAU,CDAA;ADArB,wBDAAM,ODAA,EDAqB,ADArB,CDAAF,QDAqB;ADAA;ADAA;ADAQ;ADAA,wBDAAE,ODAA,EDAC,ADAD,EDAC;ADAA;ADCpB,oBDAAJ,QDAA,EDAa,A,KDAb,ODAa,CDAA,ADAb,QDAa,CDAA,ADAbI,ODAE,CDAW,CDAA;ADAhC,wBDAIN,gBDAW,ADAX,GDA4B,ADAb,CDAAE,QDAa;ADAE;ADAE,wBDAAD,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,6BDAAM,ODAY;ADAA;ADChD,wBDCE,ADDIR,aDCJ,GDAI,ADAJ,KDAI;ADAI;ADAA,wBDAAE,WDAA,EDAQ,ADAR,CDAAI,ODAE,ADAF,GDAQ,ADAF,CDAAC,ODAE;ADAA;ADAA,wBDAA,ADDlB,KDEE,ADFIP,aDEJ,GDAI,ADAJ,KDAI;ADAI;ADAA,wBDAAE,WDAA,EDAQ,ADAR,CDAAI,ODAE,ADAF,GDAQ,ADAF,CDAAC,ODAE;ADAA;ADAA,wBDAA,ADFlB,KDGE,ADHIP,aDGJ,GDAG,ADAH,IDAG;ADAI;ADAA,wBDAAE,WDAA,EDAO,ADAP,CDAAI,ODAE,ADAF,EDAO,ADAF,CDAAC,ODAE;ADAA;ADAA,wBDAA,ADHhB,KDIE,ADJIP,aDIJ,GDAG,ADAH,IDAG;ADAI;ADAA,wBDAAE,WDAA,EDAO,ADAP,CDAAI,ODAE,ADAF,EDAO,ADAF,CDAAC,ODAE;ADAA;ADAA,wBDAA,ADJhB,KDKE,ADLIP,aDKJ,GDAI,ADAJ,KDAI;ADAI;ADAA,wBDAAE,WDAA,EDAQ,ADAR,CDAAI,ODAE,ADAF,GDAQ,ADAF,CDAAC,ODAE;ADAA;ADAA,wBDAA,ADLlB,KDME,ADNIP,aDMJ,GDAI,ADAJ,KDAI;ADAI;ADAA,wBDAAE,WDAA,EDAQ,ADAR,CDAAI,ODAE,ADAF,GDAQ,ADAF,CDAAC,ODAE;ADAA;ADAA;ADCR;ADAA,wBDAAL,WDAA,EDAK,ADAL,MDAK;ADAA;ADCd,iBDCF;ADbmF,gBDAAM,ODanF,CDAA;ADbmF;ADAA;ADanF;ADAA,kBDAA,ADb2E,CDAAN,WDAA;ADa3E;ADED,uBDA+E,KDAO,ADAlF,CDAAO,kBDAa,CDAc,MDAM,ADAnB,CDAAV,gBDAmB,CDAY,ODAM,ADAhB,CDAAC,aDAgB,CDAe,ODAM,ADAnB,CDAAC,gBDAmB,CDU3E;ADVsF,SDAA;ADAR,gBDAO,ADAP,CDAAC,WDAO;ADCpF,gBDCE,ADDIF,aDCJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAAE,WDAA,EDA0B,ADA1B,CDAAH,gBDAW,ADAX,GDA0B,ADAX,CDAAE,gBDAW;ADAA;ADAA,gBDAA,ADDpC,KDEE,ADFID,aDEJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAAE,WDAA,EDA0B,ADA1B,CDAAH,gBDAW,ADAX,GDA0B,ADAX,CDAAE,gBDAW;ADAA;ADAA,gBDAA,ADFpC,KDGE,ADHID,aDGJ,GDAG,ADAH,IDAG;ADAI;ADAA,gBDAAE,WDAA,EDAyB,A,IDAzB,qCDAAH,gBDAW,CDAG,CDAAE,gBDAW;ADAA;ADAA,gBDAA,ADHlC,KDIE,ADJID,aDIJ,GDAG,ADAH,IDAG;ADAI;ADAA,gBDAAE,WDAA,EDAyB,A,IDAzB,qCDAAH,gBDAW,CDAG,CDAAE,gBDAW;ADAA;ADAA,gBDAA,ADJlC,KDKE,ADLID,aDKJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAAE,WDAA,EDA0B,A,IDA1B,qCDAAH,gBDAW,CDAI,CDAAE,gBDAW;ADAA;ADAA,gBDAA,ADLpC,KDME,ADNID,aDMJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAAE,WDAA,EDA0B,A,IDA1B,qCDAAH,gBDAW,CDAI,CDAAE,gBDAW;ADAA;ADAA;ADC1B;ADAA,gBDAAC,WDAA,EDAK,ADAL,MDAK;ADAA;ADEhB,kBDAA,ADV8E,CDAAA,WDAA;ADU9E;ADiCD,uBDA8B,A,KDAA,WDAW,ADArC,CDAAQ,YDAO,CDAU,MDAM,ADAf,CDAAC,YDAe,CDI1B;ADJyC,SDCpC;A,gBDAA,UDAC,ADAD,CDAAC,MDAC,EDAG,IDAA,A,KDAA,UDAgB,GDCtB;ADAF,YDAAA,MDAC,CDACC,UDAU,CDACF,YDAO,CDAC;ADCrB,mBDAAC,MDAC,CDAY;ADAA;ADOf,uBDA+C,A,KDAA,WDAW,ADAtD,CDAAE,kBDAa,CDAe,A,GDAA,aDAY,CDAA,ADAZ,MDAY,CDAA,ADA1B,CDAAC,iBDA0B,CDY3C;ADZ0D,SDAA;A,gBDAZ,WDAW,ADAX,CDAAb,WDAW,CDEtD;A,gBDAA,WDAAc,QDAA;ADEoB,kBDAe,ADAf,CDAAC,QDAe,CDCtB;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA;ADCO,eDAmB,ADAnB,CDAAC,QDAmB;ADCnB,kBDAe,ADAf,CDAAC,QDAe,CDCxB;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDAA;ADPb,gBDAIR,iBDAY,CDAO,KDAA,ADAnB,GDAwB,ADAD,EDAC;ADAE;ADC5B,gBDAAC,QDAA,MDAA,A,KDAA;ADAI,gBDAAA,QDAA,CDAAH,UDAA,IDAC,EDAA;ADAL,gBDAAX,WDAA,GDAAc,QDAA;ADAA;ADCD;ADAM;ADCe,gBDAAC,QDAA,EDAe,ADAf,CDAAF,iBDAY,CDAC,CDAC,CDAC,CDAA;A,oBDA/B,WDAK,ADAL,CDAAS,UDAK,EDAG,CDAAd,YDAO,CDACO,QDAe,CDAC;ADCvB,gBDAAC,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAAO,cDAA,CDAAD,UDAK,EDAA;ADAX,gBDAAL,QDAA,GDAAD,QDAA,aDAA;A,oBDAT,WDAM,ADAN,CDAAQ,WDAM,EDAG,CDAAP,QDAa;ADCjB,mBDAC,ADAD,CDAAQ,MDAC,EDAG,EDAC,CDAA;ADAd;ADAoD,iBDAA;ADAhC,oBDAAP,QDAA,EDAmB,ADAnB,CDAAL,iBDAY,CDAO,MDAA;ADAvB,yBDAuB,CDAA,ADAvBY,MDAC,ADAD,EDAuB,ADAnB,CDAAP,QDAmB;ADCnB,oBDAAC,QDAA,EDAe,ADAf,CDAAN,iBDAY,CDACY,MDAC,CDAC,CDAA;A,wBDA7B,WDAG,ADAH,CDAAC,QDAG,EDAG,CDAAlB,YDAO,CDACW,QDAe,CDAC;ADCzB,oBDAAC,QDAA,MDAA,A,KDAA;ADAM,oBDAAA,QDAA,CDAAG,cDAA,CDAAC,WDAM;ADAC,oBDAAJ,QDAA,CDAAT,UDAA,KDAE;ADAE,oBDAAS,QDAA,CDAAG,cDAA,CDAAG,QDAG,EDAA;ADApB,oBDAAL,QDAA,GDAAD,QDAA,aDAA;ADAT,oBDAAI,WDAM,ADAN,EDA+B,ADAtB,CDAAH,QDAsB,CDAA;ADFQ,oBDAAI,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA,iBDGjD;ADNI,gBDAAzB,WDAA,EDQN,ADRM,CDAAwB,WDQN;ADAA;ADCF,kBDAA,ADZ8C,CDAAxB,WDAA;ADY9C,SDAA;ADzCD,uBDA+B,ODAM,ADAjC,CDAA2B,kBDAa,CDAK,MDAM,ADAV,CDAAC,ODAU,CDY3B;ADZqC,SDAA;ADAP,kBDAM,ADAN,CDAA5B,WDAM;ADCnC,gBDCE,ADDI4B,ODCJ,GDAG,ADAH,IDAG;ADAI;ADAA,gBDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA;ADAA,gBDAA,ADDZ,KDEE,ADFI4B,ODEJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA;ADAA,gBDAA,ADFb,KDGE,ADHI4B,ODGJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA;ADAA,gBDAA,ADHd,KDIE,ADJI4B,ODIJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA;ADAA,gBDAA,ADJd,KDKE,ADLI4B,ODKJ,GDAG,ADAH,IDAG;ADAI;ADAA,gBDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA;ADAA,gBDAA,ADLZ,KDME,ADNI4B,ODMJ,GDAG,ADAH,IDAG;ADAI;ADAA,gBDAA5B,WDAA,EDAG,ADAH,IDAG;ADAA;ADAA,gBDAA,ADNZ,KDOE,ADPI4B,ODOJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA;ADAA,gBDAA,ADPd,KDQE,ADRI4B,ODQJ,GDAI,ADAJ,KDAI;ADAI;ADAA,gBDAA5B,WDAA,EDAI,ADAJ,KDAI;ADAA;ADAA;ADCJ;ADAA,gBDAAA,WDAA,EDAG,ADAH,IDAG;ADAA;ADEd,kBDAA,ADZ8B,CDAAA,WDAA;ADY9B;ADoCD,uBDA4D,A,KDAA,WDAW,ADAnE,CDAA6B,sBDAiB,CDAS,WDAW,ADAnB,CDAAC,WDAmB,CDAU,ODAM,ADAd,CDAAC,WDAc,CDexD;ADfuE,SDAA;A,gBDAZ,WDAW,ADAX,CDAA/B,WDAW,CDOjE;A,gBDAA,WDAAgC,QDAA,CDEA;A,gBDAA,WDAAC,QDAA,CDIF;A,gBDAA,WDAAC,QDAA,CDAA;ADRa,eDAsB,ADAtB,CDAAC,QDAsB,CDAA;ADJnB,kBDAY,ADAZ,CDAAC,QDAY,EDAA,ADAZ,CDAAN,WDAM,CDAM,MDAA;A,gBDA1B,WDAG,ADAH,CDAAJ,QDAG,EDAG,CDAAlB,YDAO,CDAC4B,QDAY,CDAC;ADCA,kBDAe,ADAf,CDAAC,QDAe,EDAA,ADAf,CDAAP,WDAM,CDAS,SDAA;A,gBDA1C,WDAE,ADAF,CDAAF,ODAE,EDAG,CDAApB,YDAO,CDACmB,kBDAa,CDACU,QDAe,CDAC,CDAC;ADChB,kBDAY,ADAZ,CDAAC,QDAY,EDAA,ADAZ,CDAAR,WDAM,CDAM,MDAA;ADA5B,iBDA6B,ADA7B,CDAAS,QDA6B,CDAA;ADA7B,YDAAA,QDAA,EDA6B,ADA7B,CDAAR,WDAM,CDACS,QDAQ,CDACF,QDAY,CDAC,CDAA;ADAzC,iBDAS,ADAT,CDAAG,cDAS,EDAG,CDAAF,QDA4C;ADC5D,gBDAIE,cDAS,CDAU,SDAA,ADAnB,GDA4B,ADAL,MDAK;ADAE;ADC5B,mBDAM,ADAN,CDAAC,WDAwC,CDAA;ADA/B;ADAA;ADAA,oBDAAP,QDAA,EDAsB,A,IDAtB,IDAsB,CDAA,ADAtB,KDAsB,CDAA,ADAtBL,WDAM,CDAM,MDAU,CDAA;ADAtB,oBDAAY,WDAA,EDAsB,ADAtB,CDAAP,QDAsB;ADAA;ADAA;ADAQ;ADAA,oBDAAO,WDAA,EDAC,ADAD,EDAC;ADAA;ADC5C,oBDAIZ,WDAM,CDAM,KDAA,ADAZ,GDAiC,A,KDAjB,ODAiB,CDAA,ADAjB,QDAiB,CDAA,ADAjBY,WDAM,CDAW;ADAE;ADCrC,oBDAAV,QDAA,MDAA,A,KDAA;ADAI,oBDAAA,QDAA,CDAArB,UDAA,QDAK,EDAA;ADAT,oBDAAX,WDAA,GDAAgC,QDAA;ADAA;ADCD;ADAM;ADCL,oBDAAC,QDAA,MDAA,A,KDAA;ADAM,oBDAAA,QDAA,CDAAV,cDAA,CDAAG,QDAG;ADAC,oBDAAO,QDAA,CDAAtB,UDAA,IDAC;ADAE,oBDAAsB,QDAA,CDAAV,cDAA,CDAAK,ODAE;ADAC,oBDAAK,QDAA,CDAAtB,UDAA,IDAC;ADAE,oBDAAsB,QDAA,CDAAU,WDAA,CDAAD,WDAM,EDAA;ADAzB,oBDAA1C,WDAA,GDAAiC,QDAA;ADAA;ADCD;ADCF;ADAM;ADCD,sBDAM,ADAN,CDAAW,WDAM,EDAG,CDAAd,WDAM,CDAM;ADCzB,gBDAAI,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAAX,cDAA,CDAAG,QDAG;ADAC,gBDAAQ,QDAA,CDAAvB,UDAA,IDAC;ADAE,gBDAAuB,QDAA,CDAAX,cDAA,CDAAK,ODAE;ADAC,gBDAAM,QDAA,CDAAvB,UDAA,IDAC;ADAE,gBDAAuB,QDAA,CDAAW,YDAA,CDAAD,WDAM,EDAA;ADAzB,gBDAA5C,WDAA,GDAAkC,QDAA;ADAA;ADEH,kBDAA,ADf2D,CDAAlC,WDAA;ADe3D;ADID,uBDA4C,A,KDAA,WDAW,ADAnD,CDAA8C,eDAU,CDAU,A,GDAA,aDAiB,CDAA,ADAjB,WDAiB,CDAA,ADA1B,CDAAC,YDA0B,CDUxC;ADVuD,SDED;A,gBDAA,WDAgB,ADAhB,CDAAC,QDAgB,CDAU;A,gBDAA,WDAe,ADAf,CDAAC,QDAe;ADE1E,eDAc,ADAd,CDAAC,QDAc;ADCd,kBDAgB,ADAhB,CDAAC,QDAgB,CDCc;A,gBDAA,WDAgB,ADAhB,CDAAC,QDAgB,CDAU;A,gBDAA,WDAe,ADAf,CDAAC,QDAe,CDChF;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDAA;A,gBDDqC,WDAoB,ADApB,CDAAC,QDAoB,CDAA;ADLhD,kBDAgB,ADAhB,CDAAC,QDAgB,EDAA,ADAhB,CDAAV,YDAO,CDAC,CDAC,CDAC,CDAM,MDAA;A,gBDAhC,WDAK,ADAL,CDAAzB,UDAK,EDAG,CDAAd,YDAO,CDACiD,QDAgB,CDAC,CDCjC;A,gBDAA,WDAQ,ADAR,CDAAC,aDA4F,CDAA;ADAjF,gBDAIX,YDAO,CDAC,CDAC,CDAC,CDAU,SDAA,ADApB,GDA8B,ADAN,ODAM;ADAE;ADAE,gBDAAC,QDAA,EDAgB,ADAhB,CDAAxC,YDAO,CDAC,ODAO,CDAC,CDAA;ADAhB,gBDAAkD,aDAA,EDAgB,ADAhB,CDAAV,QDAgB;ADAA;ADAE;ADAM;ADAE,gBDAAC,QDAA,EDAe,ADAf,CDAAzC,YDAO,CDAC,MDAM,CDAC,CDAA;ADAf,gBDAAkD,aDAA,EDAe,ADAf,CDAAT,QDAe;ADAA,aDCjF;A,gBDAA,WDAAU,QDAA,MDAA,A,KDAA;ADAM,YDAAA,QDAA,CDAApC,cDAA,CDAAD,UDAK;ADAG,YDAAqC,QDAA,CDAApC,cDAA,CDAAmC,aDAQ,EDAA;A,gBDAtB,YDAAE,QDAA,GDAAD,QDAA,aDAA;A,gBDAT,WDAM,ADAN,CDAAnC,WDAM,EDAG,CDAAoC,QDAwB;ADC5B,eDAC,ADAD,CDAAnC,MDAC,EDAG,EDAC,CDAA;ADAd;ADA+C,aDAA;ADA3B,gBDAAyB,QDAA,EDAc,ADAd,CDAAH,YDAO,CDAO,MDAA;ADAlB,qBDAkB,CDAA,ADAlBtB,MDAC,ADAD,EDAkB,ADAd,CDAAyB,QDAc;ADCd,gBDAAC,QDAA,EDAgB,ADAhB,CDAAJ,YDAO,CDACtB,MDAC,CDAC,CDAM,MDAA;A,oBDA9B,WDAG,ADAH,CDAAC,QDAG,EDAG,CDAAlB,YDAO,CDAC2C,QDAgB,CDAC;ADCzB,oBDAIJ,YDAO,CDACtB,MDAC,CDAC,CDAU,SDAA,ADApB,GDA8B,ADAN,ODAM;ADAE;ADAE,oBDAA2B,QDAA,EDAgB,ADAhB,CDAA5C,YDAO,CDAC,ODAO,CDAC,CDAA;ADAhB,oBDAAgD,QDAA,EDAgB,ADAhB,CDAAJ,QDAgB;ADAA;ADAE;ADAM;ADAE,oBDAAC,QDAA,EDAe,ADAf,CDAA7C,YDAO,CDAC,MDAM,CDAC,CDAA;ADAf,oBDAAgD,QDAA,EDAe,ADAf,CDAAH,QDAe;ADAA,iBDAE;A,oBDAvF,WDAG,ADAH,CDAAQ,QDAG,EDAG,CDAAL,QDAiF;ADClF,gBDAAF,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAA/B,cDAA,CDAAC,WDAM;ADAC,gBDAA8B,QDAA,CDAA3C,UDAA,KDAE;ADAE,gBDAA2C,QDAA,CDAA/B,cDAA,CDAAG,QDAG;ADAG,gBDAA4B,QDAA,CDAA/B,cDAA,CDAAsC,QDAG,EDAA;ADA1B,gBDAAN,QDAA,GDAAD,QDAA,aDAA;ADAT,gBDAA9B,WDAM,ADAN,EDAqC,ADA5B,CDAA+B,QDA4B,CDAA;ADHH,gBDAA9B,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA;ADK7C,mBDAAD,WDAM;ADAA;ADWD,qBDOJ,A,KDAA,WDAW,ADPH,WDAU,CDCX,MDAM,ADAd,CDAAO,WDAc,CDCA,A,IDAA,aDAY,CDAA,ADAZ,MDAY,CDAA,ADA1B,CDAAlB,iBDA0B,CDCZ,A,IDAA,aDAiB,CDAA,ADAjB,WDAiB,CDAA,ADA/B,CDAAiD,iBDA+B,CDCjB,A,IDAA,aDAiB,CDAA,ADAjB,WDAiB,CDAA,ADA/B,CDAAC,iBDA+B,CDCnB,IDAG,ADAf,CDAAC,eDAe,CDCF,IDAG,ADAhB,CDAAC,gBDAgB,CDiCjB;ADhCc;ADcwB,uBDAa,ADAb,CDAAC,QDAa,CDAA;A,gBDA/B,WDAwC,ADAxC,CDAAC,QDAwC;ADCrC,eDAiB,ADAjB,CDAAC,QDAiB;ADCN,uBDAa,ADAb,CDAAC,QDAa,CDC7B;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDEN;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDIA;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDGA;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDGA;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDAA;AD5B0C,gBDAO,ADAtB,CDAAzE,QDAA,CDAM,MDAM,ADAT,CDAA0E,MDAS,CDEjD;ADDC;ADAA,sBDAO,ADAP,CDAAjD,WDAM,CDACkD,QDAQ,CDACD,MDAC,CDAC;ADAA,aDAA;A,eDDhB,aDAW,CDAA,ADAX,MDAW,CDAA,ADAX,CDAAE,gBDAW,EDAG,A,IDAA,MDEjB,CDAA,ADFiB,cDEjB,CDAA,A,GDFiB,UDEjB,CDAA,ADFiB,KDEjB,CDAA,ADFiBrE,iBDAY,CDAQ,EDAA,A,IDAA,IDErC,CDAA,ADFqC,MDErC,CDAA,ADFqC,KDErC,EDAA,ADFqC,CDAAP,QDErC;ADCwD,gBDAO,ADA3B,CDAAA,QDAA,CDAM,WDAW,ADAd,CDAA6E,MDAc,CDErD;ADDC;ADAgB,sBDAO,ADAP,CDAAC,QDAO,EDAA,ADAP,CDAAD,MDAC,CDAM,MDAA;ADAvB,sBDAO,ADAP,CDAApD,WDAM,CDACkD,QDAQ,CDACG,QDAO,CDAC;ADAA,aDAA;A,eDDtB,aDAU,CDAA,ADAV,WDAU,CDAA,ADAV,CDAAC,eDAU,EDAG,A,IDAA,MDEhB,CDAA,ADFgB,cDEhB,CDAA,A,GDFgB,UDEhB,CDAA,ADFgB,KDEhB,CDAA,ADFgBvB,iBDAY,CDAQ,EDAA,A,IDAA,IDEpC,CDAA,ADFoC,WDEpC,CDAA,ADFoC,KDEpC,EDAA,ADFoC,CDAAxD,QDEpC;ADCwD,gBDAO,ADA3B,CDAAA,QDAA,CDAM,WDAW,ADAd,CDAA6E,MDAc,CDErD;ADDC;ADAgB,sBDAO,ADAP,CDAAG,QDAO,EDAA,ADAP,CDAAH,MDAC,CDAM,MDAA;ADAvB,sBDAO,ADAP,CDAApD,WDAM,CDACkD,QDAQ,CDACK,QDAO,CDAC;ADAA,aDAA;A,eDDtB,aDAU,CDAA,ADAV,WDAU,CDAA,ADAV,CDAAC,eDAU,EDAG,A,IDAA,MDEhB,CDAA,ADFgB,cDEhB,CDAA,A,GDFgB,UDEhB,CDAA,ADFgB,KDEhB,CDAA,ADFgBxB,iBDAY,CDAQ,EDAA,A,IDAA,IDEpC,CDAA,ADFoC,WDEpC,CDAA,ADFoC,KDEpC,EDAA,ADFoC,CDAAzD,QDEpC;ADCmB,kBDAgB,ADAhB,CDAAkF,QDAgB,EDAA,ADAhB,CDAAzD,WDAM,CDAU,UDAA;A,gBDAhC,WDAK,ADAL,CDAA0D,UDAK,EDAG,CDAAjF,YDAO,CDACgF,QDAgB,CDAC,CDCjC;A,gBDAA,WDAI,ADAJ,CDAAE,SDAI,EDAG,CDAA9E,kBDAa,CDACsE,gBDAW,CDAC,CDCxB;A,gBDAA,WDAAS,QDAA,MDAA,A,KDAA;ADAI,YDAAA,QDAA,CDAAhF,UDAA,UDAO;ADAE,YDAAgF,QDAA,CDAApE,cDAA,CDAAmE,SDAI;ADAC,YDAAC,QDAA,CDAAhF,UDAA,SDAM;ADAE,YDAAgF,QDAA,CDAApE,cDAA,CDAAkE,UDAK,EDAA;A,gBDA/B,YDAAG,QDAA,GDAAD,QDAA,aDAA;A,gBDAT,WDAM,ADAN,CDAAnE,WDAM,EDAG,CDAAoE,QDAiC;ADC9C,gBDAIP,eDAU,CDAO,KDAA,ADAjB,EDAqB,ADAD,EDAC;ADAE;ADCU,gBDAAnB,QDAA,EDAa,ADAb,CDAAmB,eDAU,CDAC,CDAC,CDAC,CDAA;ADA/B,gBDAAlB,QDAA,EDAwC,ADAxC,CDAAtC,sBDAiB,CDACqC,QDAa,CDAE,CDAAnC,WDAM,CDAC,CDAA;A,oBDArD,WDAU,ADAV,CDAA8D,eDAU,EDAG,CDAA1B,QDAwC;ADChD,mBDAC,ADAD,CDAA1C,MDAC,EDAG,EDAC,CDAA;ADAd;ADAkD,iBDAA;ADA9B,oBDAA2C,QDAA,EDAiB,ADAjB,CDAAiB,eDAU,CDAO,MDAA;ADArB,yBDAqB,CDAA,ADArB5D,MDAC,ADAD,EDAqB,ADAjB,CDAA2C,QDAiB;ADCN,oBDAAC,QDAA,EDAa,ADAb,CDAAgB,eDAU,CDAC5D,MDAC,CDAC,CDAA;A,wBDAtC,WDAI,ADAJ,CDAAqE,SDAI,EDAG,CDAAjE,sBDAiB,CDACwC,QDAa,CDAE,CDAAtC,WDAM,CDAC;ADCtC,oBDAAuC,QDAA,MDAA,A,KDAA;ADAM,oBDAAA,QDAA,CDAA/C,cDAA,CDAAsE,eDAU;ADAC,oBDAAvB,QDAA,CDAA3D,UDAA,QDAK;ADAE,oBDAA2D,QDAA,CDAA/C,cDAA,CDAAuE,SDAI,EDAA;ADA5B,oBDAAvB,QDAA,GDAAD,QDAA,aDAA;ADAb,oBDAAuB,eDAU,ADAV,EDA2C,ADA9B,CDAAtB,QDA8B,CDAA;ADFN,oBDAA9C,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA;ADIvC,gBDAA+C,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAAjD,cDAA,CDAAC,WDAM;ADAC,gBDAAgD,QDAA,CDAA7D,UDAA,UDAO;ADAE,gBDAA6D,QDAA,CDAAjD,cDAA,CDAAsE,eDAU,EDAA;ADAhC,gBDAApB,QDAA,GDAAD,QDAA,aDAA;ADAT,gBDAAhD,WDAM,ADAN,EDA2C,ADAlC,CDAAiD,QDAkC;ADAA;ADE7C,gBDAIc,eDAU,CDAO,KDAA,ADAjB,EDAqB,ADAD,EDAC;ADAE,aDCrB;A,oBDAA,WDAQ,ADAR,CDAAQ,aDAQ,EDAG,CDAAjD,eDAU,CDACyC,eDAU,CDAC;ADC5B,gBDAAb,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAAnD,cDAA,CDAAC,WDAM;ADAC,gBDAAkD,QDAA,CDAA/D,UDAA,aDAU;ADAE,gBDAA+D,QDAA,CDAAnD,cDAA,CDAAwE,aDAQ,EDAA;ADAjC,gBDAApB,QDAA,GDAAD,QDAA,aDAA;ADAT,gBDAAlD,WDAM,ADAN,EDA4C,ADAnC,CDAAmD,QDAmC;ADAA;ADE9C,gBDAIX,eDAU,ADAV,GDAe,ADAD,EDAC;ADAE;ADCV,gBDAAY,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAArD,cDAA,CDAAC,WDAM;ADAC,gBDAAoD,QDAA,CDAAjE,UDAA,UDAO;ADAE,gBDAAiE,QDAA,CDAAjC,WDAA,CDAAqB,eDAU,EDAA;ADAhC,gBDAAa,QDAA,GDAAD,QDAA,aDAA;ADAT,gBDAApD,WDAM,ADAN,EDA2C,ADAlC,CDAAqD,QDAkC;ADAA;ADE7C,gBDAIZ,gBDAW,ADAX,EDAe,ADAD,EDAC;ADAE;ADCV,gBDAAa,QDAA,MDAA,A,KDAA;ADAM,gBDAAA,QDAA,CDAAvD,cDAA,CDAAC,WDAM;ADAC,gBDAAsD,QDAA,CDAAnE,UDAA,WDAQ;ADAE,gBDAAmE,QDAA,CDAAnC,WDAA,CDAAsB,gBDAW,EDAA;ADAlC,gBDAAc,QDAA,GDAAD,QDAA,aDAA;ADAT,gBDAAtD,WDAM,ADAN,EDA6C,ADApC,CDAAuD,QDAoC;ADAA;ADE/C,mBDAAvD,WDAM;ADAA,SDCP;AD/bM,qBDKJ,MDAK,ADLG,MDAK,CDCR,MDAM,ADAZ,CDAAwE,SDAY,CDCD,ODAM,ADAjB,CDAAC,cDAiB,CDCL,KDAO,ADAnB,CDAAC,eDAmB,CDCT,KDAO,ADAjB,CDAAC,aDAiB,CDGlB;ADFQ;ADCP,4BDAgD,CDAA,ADAtCH,SDAI,CDAE,CDAAC,cDAS,CDAE,CDAAC,eDAU,CDAE,CDAAC,aDAQ,CDAC;ADAA;ADS3C,qBDAqC,KDAO,ADAxC,kBDAiB,CDAO,MDAM,ADAZ,CDAAH,SDAY,CDgBxC;ADhBmD,SDAA;ADAR,gBDAO,ADAP,CDAAhG,WDAO,CDAA;A,gB,Q;ADAC;ADAA;ADClD,wBDAI,MDAY,CDAA,ADAZ,aDAY,CDAA,ADAZgG,SDAI,CDAQ;ADAE;ADAE,wBDAAhG,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,6BDAAM,ODAY;ADAA;ADChC,2BDAA+F,UDAA,EDAc,CDAAL,SDAI,ADAlB,CDAA;A,wB,W;A;A;A,oD,U,E,W;A,4B,e,qB,U,E,W;ADAS,2BDAC,ADAD,CDAAb,MDAC,EDAA,A,C,eDAA;ADCR,4BDAIA,MDAC,ADAD,GDAY,ADAP,GDAO,CDCd,KDAIA,MDAC,ADAD,GDAY,ADAP,GDAO,CDCd,KDAIA,MDAC,ADAD,EDAW,ADAP,IDAO;ADAE;ADAE,4BDAAnF,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,iCDAAM,ODAY;ADAA;ADAG,4BDAA,ADDpC,KDEW6E,MDAC,ADAD,GDAY,ADAP,GDAO,CDCrB,KDAIA,MDAC,ADAD,EDAW,ADAP,GDAO;ADAE;ADAE,4BDAAnF,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,iCDAAM,ODAY;ADAA;ADAG,4BDAA,ADHpC,KDIW6E,MDAC,ADAD,GDAY,ADAP,GDAO,CDCrB,KDAIA,MDAC,ADAD,EDAW,ADAP,GDAO;ADAE;ADAE,4BDAAnF,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,iCDAAM,ODAY;ADAA;ADAG;ADC7B;ADCL,4BDAAN,WDAY,ADAZ,EDAY,ADAL,MDAK,CDAA;ADAZ,iCDAAM,ODAY;ADAA,yBDEf;A,wB,Q,sB,U,E,W;A,wB,W,G,Q;A;ADbuC,oBDAAN,WDe1C,EDAI,ADAJ,KDAI;ADAA,iBDCL;ADhBmD,gBDAAM,ODgBnD,CDAA;ADhBmD;ADAA;ADgBnD;ADAA,kBDAA,ADhB2C,CDAAN,WDAA;ADgB3C;ADEM,qBDAoD,ODAM,ADAtD,ODAM,CDAY,MDAM,ADAjB,CDAAwG,cDAiB,CDAU,A,IDAA,aDAW,CDAA,ADAX,KDAW,CDAA,ADAnB,CDAAC,WDAmB,CDOvD;ADPiE;ADChE,gBDAI,CDA6B,ADA5B,iBDAiB,CDACD,cDAS,CDAC,CDAI,UDAA,A,KDAA,SDAO;ADCxC,iBDAO,ADAP,CDAAE,YDAO,EDAG,UDAmC,CDAA,ADAzB,IDAI,CDAE,MDAK,CDAE,KDAI,CDAE,MDAK,CDAC,CDC7C;A,eDAA,KDAS,CDAA,ADAT,KDAS,CDAA,ADAT,CDAAC,cDAS,EDAG,IDAA,A,IDAA,IDAwB,CDAA,ADAxB,KDAwB,IDCxC;A,eDAA,MDAsB,CDAA,ADAtB,GDAsB,CDAA,ADAtBA,cDAS,CDAK,CDAAD,YDAO,CDAC,CDCtB;A,eDAA,MDAwB,CDAA,ADAxB,MDAwB,CDAA,ADAxBC,cDAS,CDAQ,CDAAF,WDAM,CDAC,CDCF;A,eDAA,aDAkB,CDAA,ADAlB,KDAkB,CDAA,ADAlB,CDAAG,QDAkB,EDAA,A,IDAlB,MDAkB,CDAA,ADAlB,cDAkB,CDAA,ADAlBD,cDAS,CDAS,CDAA;ADAxC,6BDAyC,CDAA,ADA9BH,cDAS,CDAE,CDAAI,QDAkB,CDAC;ADAA;ADgapC,qBDGJ,A,KDAA,WDAW,ADHH,YDAW,CDCZ,MDAM,ADAd,CDAA7E,WDAc,CDCN,A,IDAA,mBDAmB,CDAA,ADAnB,MDAmB,CDAA,ADAnB,ODAmB,CDAA,ADA3B,CDAA8E,WDA2B,CD6B5B;AD5Bc,SDAA;A,gBDAZ,WDAW,ADAX,CDAA7G,WDAW;ADCQ,kBDAgB,ADAhB,CDAA8G,QDAgB,CDCpB;A,eDAA,aDAa,CDAA,ADAb,KDAa,CDAA,ADAb,CDAAC,QDAa,CDIpB;A,gBDAA,WDAAC,QDAA,CDGP;A,eDAA,aDA8C,CDAA,ADA9C,MDA8C,CDAA,ADA9C,CDAAC,QDA8C;ADEpB,kBDAiB,ADAjB,CDAAC,QDAiB,CDG3C;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDEA;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA;ADEkB,eDAgB,ADAhB,CDAAC,QDAgB;ADCX,kBDAiB,ADAjB,CDAAC,QDAiB,CDG/B;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDEA;A,gBDAA,WDAAC,QDAA,CDAA;A,gBDAA,YDAAC,QDAA,CDGX;A,gBDAA,WDAAC,QDAA,CDAA;ADdW,eDAkB,ADAlB,CDAAC,QDAkB,CDAA;A,gBDDmB,WDG/C,ADH+C,CDAAC,QDG/C;ADMY,eDAa,ADAb,CDAAC,QDAa,CDAA;ADAb,eDAa,ADAb,CDAAC,QDAa,CDAA;ADrBb;ADAA;ADCO,oBDAAnB,QDAA,EDAgB,ADAhB,CDAA/E,WDAM,CDAU,UDAA;A,wBDAhC,WDAK,ADAL,CDAA0D,UDAK,EDAG,CDAAjF,YDAO,CDACsG,QDAgB,CDAC;ADCrB,oBDAAC,QDAA,EDAa,ADAb,CDAAhF,WDAM,CDAO;ADAsB,wBDAO,ADArB,CDAAzB,QDAA,CDAM,KDAK,ADAR,CDAA0E,MDAQ,CDE/C;ADDC;ADAW,8BDAM,ADAN,CDAAkD,QDAM,EDAA,ADAN,CDAAlD,MDAC,CDAK,KDAA;ADAjB,8BDAA,A,IDAA,MDAkB,CDAA,ADAlB,WDAkB,CDAA,ADAlB6B,WDAM,CDAK,CDAAqB,QDAM,CDAC;ADAA,qBDAA;A,uBDDhB,aDAS,CDAA,ADAT,KDAS,CDAA,ADAT,CDAAC,cDAS,EDAG,A,IDAA,MDEf,CDAA,ADFe,cDEf,CDAA,A,GDFe,UDEf,CDAA,ADFe,KDEf,CDAA,ADFepB,QDAa,CDAQ,EDAA,A,IDAA,IDEpC,CDAA,ADFoC,KDEpC,CDAA,ADFoC,KDEpC,EDAA,ADFoC,CDAAzG,QDEpC;ADCD,wBDAI6H,cDAS,CDAO,KDAA,ADAhB,GDAqB,ADAD,EDAC;ADAE;ADClB,wBDAAnB,QDAA,MDAA,A,KDAA;ADAA,wBDAAhH,WDAA,GDAAgH,QDAA,aDAA;ADAP,6BDAA1G,ODAY;ADAA;ADGgB,0BDAM,ADApB,CDAAA,QDAA,CDAM,KDAK,ADAR,CDAA0E,MDAQ,CDAqB;ADAR;ADAA,+BDAAA,MDAC,CDAK;ADAA,qBDAA;ADA5C,oBDAAiC,QDAA,EDA8C,A,IDA9C,MDA8C,CDAA,ADA9C,cDA8C,CDAA,A,GDA9C,UDA8C,CDAA,ADA9C,MDA8C,CDAA,ADA9CkB,cDAS,CDAK,EDAA,A,IDAA,IDAgC,CDAA,ADAhC,KDAgC,CDAA,ADAhC,ODAgC,EDAA,ADAhC,CDAA7H,QDAgC,GDAA;A,wBDD5C,WDAQ,ADAR,CDAA8H,aDAQ,EDAG,CDAAxH,kBDAa,CDC1BqG,QDA8C,CDC/C;ADC2B,oBDAAC,QDAA,EDAiB,ADAjB,CDAAiB,cDAS,CDAC,CDAC,CDAC,CDAK,KDAA;ADAzC,0BDAQ,ADAR,CDAAE,aDAQ,EDAG,A,IDAA,MDAmC,CDAA,ADAnC,YDAmC,CDAA,ADAnCxB,WDAM,CDAO,CDAAK,QDAiB,CDAE,GDAE,CDAC;ADCvC,wBDAIiB,cDAS,CDAC,CDAC,CDAC,CDAU,SDAA,ADAtB,GDA+B,ADAL,MDAK;ADAE;ADC1C,2BDAE,ADAF,CDAAG,ODAgC,CDAA;ADA3B;ADAA;ADAA,4BDAAR,QDAA,EDAkB,A,IDAlB,IDAkB,CDAA,ADAlB,KDAkB,CDAA,ADAlBO,aDAQ,CDAU,CDAA;ADAlB,4BDAAC,ODAA,EDAkB,ADAlB,CDAAR,QDAkB;ADAA;ADAA;ADAQ;ADAA,4BDAAQ,ODAA,EDAC,ADAD,EDAC;ADAA;ADCpC,wBDAAnB,QDAA,MDAA,A,KDAA;ADAM,wBDAAA,QDAA,CDAAxE,WDAA,CDAA2F,ODAE,EDAA;ADAR,wBDAAlB,QDAA,GDAAD,QDAA,aDAA;ADF8C,wBDAAY,QDAA,EDG/C,ADH+C,CDAAX,QDG/C;ADAA;ADAA;ADAM;ADCL,wBDAAC,QDAA,MDAA,A,KDAA;ADAM,wBDAAA,QDAA,CDAAxE,YDAA,CDAAwF,aDAQ,EDAA;ADAd,wBDAAf,QDAA,GDAAD,QDAA;ADAA,wBDAAU,QDAA,EDAgB,ADAhB,CDAAT,QDAgB;ADAA,qBDCjB;A,wBDLG,WDAI,ADAJ,CDAAiB,SDAI,EDAG,CDAAR,QDKV;ADCQ,uBDAC,ADAD,CDAAtG,MDAC,EDAG,EDAC,CDAA;ADAd;ADAiD,qBDAA;ADA7B,wBDAA8F,QDAA,EDAgB,ADAhB,CDAAY,cDAS,CDAO,MDAA;ADApB,6BDAoB,CDAA,ADApB1G,MDAC,ADAD,EDAoB,ADAhB,CDAA8F,QDAgB;ADCX,wBDAAC,QDAA,EDAiB,ADAjB,CDAAW,cDAS,CDAC1G,MDAC,CDAC,CDAK,KDAA;ADApC,8BDAG,ADAH,CDAA+G,QDAG,EDAG,A,IDAA,MDAmC,CDAA,ADAnC,YDAmC,CDAA,ADAnC3B,WDAM,CDAO,CDAAW,QDAiB,CDAE,GDAE,CDAC;ADC7C,4BDAIW,cDAS,CDAC1G,MDAC,CDAC,CDAU,SDAA,ADAtB,GDA+B,ADAL,MDAK;ADAE;ADC1B;ADAA;ADAA,gCDAAuG,QDAA,EDAa,A,IDAb,IDAa,CDAA,ADAb,KDAa,CDAA,ADAbQ,QDAG,CDAU,CDAA;ADAb,gCDAAP,QDAA,EDAa,ADAb,CDAAD,QDAa;ADAA;ADAA;ADAQ;ADAA,gCDAAC,QDAA,EDAC,ADAD,EDAC;ADAA,6BDAA;ADA3B,+BDAE,ADAF,CDAAK,ODAE,EDAG,CDAAL,QDAsB;ADCxB,4BDAAR,QDAA,MDAA,A,KDAA;ADAM,4BDAAA,QDAA,CDAAlG,cDAA,CDAAgH,SDAI;ADAC,4BDAAd,QDAA,CDAA9G,UDAA,KDAE;ADAE,4BDAA8G,QDAA,CDAA9E,WDAA,CDAA2F,ODAE,EDAA;ADAjB,4BDAAZ,QDAA,GDAAD,QDAA,aDAA;ADAP,4BDAAc,SDAI,ADAJ,EDA0B,ADAnB,CDAAb,QDAmB;ADAA;ADC3B;ADAM;ADCE,4BDAAC,QDAA,MDAA,A,KDAA;ADAM,4BDAAA,QDAA,CDAApG,cDAA,CDAAgH,SDAI;ADAC,4BDAAZ,QDAA,CDAAhH,UDAA,KDAE;ADAE,4BDAAgH,QDAA,CDAA9E,YDAA,CDAA2F,QDAG,EDAA;ADAlB,4BDAAZ,QDAA,GDAAD,QDAA,aDAA;ADAP,4BDAAY,SDAI,ADAJ,EDA2B,ADApB,CDAAX,QDAoB;ADAA,yBDC5B;ADPmC,wBDAAnG,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA;ADS/C,oBDAAoG,QDAA,MDAA,A,KDAA;ADAI,oBDAAA,QDAA,CDAAlH,UDAA,eDAY;ADAE,oBDAAkH,QDAA,CDAAtG,cDAA,CDAAkE,UDAK;ADAC,oBDAAoC,QDAA,CDAAlH,UDAA,KDAE;ADAE,oBDAAkH,QDAA,CDAAtG,cDAA,CDAA6G,aDAQ;ADAC,oBDAAP,QDAA,CDAAlH,UDAA,aDAU;ADAE,oBDAAkH,QDAA,CDAAtG,cDAA,CDAAgH,SDAI;ADAC,oBDAAV,QDAA,CDAAlH,UDAA,IDAC,EDAA;ADAvD,oBDAAX,WDAA,GDAA6H,QDAA;ADAA,iBDCD;AD5Bc,gBDAAvH,OD4Bd,CDAA;AD5Bc;ADAA;AD4Bd;ADAA,kBDAA,AD5BE,CDAAN,WDAA;AD4BF;ADoXM,qBDAY,KDAI,ADAZ,KDAI,EDiFd;ADjFuB,SDCd;ADAR,YDAAL,aDAO,CDAC8I,GDAG,CDAC,uBDAuB,CDAC,CDEhC;A,eDAA,aDAU,CDAA,ADAV,KDAU,CDAA,ADAV,CDAAC,eDAU,EDAG,A,IDAA,MDIhB,CDAA,ADJgB,kBDIhB,CDAA,ADJgB,KDIhB,EDAA,ADHC,KDAK,CDAC,MDAM,CDAE,SDAQ,CDAE,MDAK,CDAE,MDAK,CDAC,CDCrC,MDAK,CDAC,KDAK,CDAE,MDAK,CDAE,MDAK,CDAE,MDAK,CDAC,CDCjC,MDAK,CDAC,ODAO,CDAE,SDAQ,CDAE,MDAK,CDAE,KDAI,CDAC,CDCtC;ADCG,kBDAU,ADAV,CDAAC,eDAU,EDAG,ODAM,CDAC,ODAO,CDAE,CDAAD,eDAU,CDAC;ADEhC,kBDAqB,ADArB,CDAAE,QDAqB,EDAA,ADArB,CDAAD,eDAU,CDACE,QDAQ,EDAE,CDAA;ADAjC,YDAAlJ,aDAO,CDAC8I,GDAG,CDACG,QDAqB,CDAC,CDC1B;ADAR,YDAAjJ,aDAO,CDAC8I,GDAG,CDAC,EDAE,CDAC;ADEX,yBDAK,ADAL,CDAAK,UDAK,EDAG,kBDAmB;ADE3B,kBDAI,ADAJ,CDAAC,SDAI,EDAS,ADAN,CDAAD,UDAK,CDACE,MDAM,CDAC,ODAO,CDAE,A,IDAA,MDI/B,CDAA,ADJ+B,YDI/B,CDAA,A,GDJuD,MDIxD,CDAA,ADJwD,kBDIxD,CDAA,A,GDJwD,YDIxD,CDAA,ADJwD,MDIxD,CDAA,ADJwD,ODIxD,GDAA,ADHC,GDAA,A,IDAA,YDAyB,CDAA,ADAzB,MDAyB,CDAA,ADAzB,ODAyB,EDAA,ADAhB,MDAM,CDAE,QDAO,CDAC,CDCzB,IDAA,A,IDAA,YDAqB,CDAA,ADArB,MDAqB,CDAA,ADArB,ODAqB,EDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCrB,IDAA,A,IDAA,YDAsC,CDAA,ADAtC,MDAsC,CDAA,ADAtC,ODAsC,EDAA,ADA7B,ODAO,CDAE,oBDAmB,CDAC,CDCvC,CDAC,CDAC;ADEC,kBDAI,ADAJ,CDAAC,SDAI,EDAS,ADAN,CDAAH,UDAK,CDACE,MDAM,CDAC,ODAO,CDAE,A,IDAA,MDI/B,CDAA,ADJ+B,YDI/B,CDAA,A,GDJuD,MDIxD,CDAA,ADJwD,kBDIxD,CDAA,A,GDJwD,YDIxD,CDAA,ADJwD,MDIxD,CDAA,ADJwD,ODIxD,GDAA,ADHC,GDAA,A,IDAA,YDAuB,CDAA,ADAvB,MDAuB,CDAA,ADAvB,ODAuB,EDAA,ADAd,MDAM,CDAE,MDAK,CDAC,CDCvB,IDAA,A,IDAA,YDAqB,CDAA,ADArB,MDAqB,CDAA,ADArB,ODAqB,EDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCrB,IDAA,A,IDAA,YDAoC,CDAA,ADApC,MDAoC,CDAA,ADApC,ODAoC,EDAA,ADA3B,ODAO,CDAE,kBDAiB,CDAC,CDCrC,CDAC,CDAC;ADEC,kBDAI,ADAJ,CDAAE,SDAI,EDAS,ADAN,CDAAJ,UDAK,CDACE,MDAM,CDAC,ODAO,CDAE,A,IDAA,MDI/B,CDAA,ADJ+B,YDI/B,CDAA,A,GDJuD,MDIxD,CDAA,ADJwD,kBDIxD,CDAA,A,GDJwD,YDIxD,CDAA,ADJwD,MDIxD,CDAA,ADJwD,ODIxD,GDAA,ADHC,GDAA,A,IDAA,YDA2B,CDAA,ADA3B,MDA2B,CDAA,ADA3B,ODA2B,EDAA,ADAlB,MDAM,CDAE,UDAS,CDAC,CDC3B,IDAA,A,IDAA,YDAqB,CDAA,ADArB,MDAqB,CDAA,ADArB,ODAqB,EDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCrB,IDAA,A,IDAA,YDAwC,CDAA,ADAxC,MDAwC,CDAA,ADAxC,ODAwC,EDAA,ADA/B,ODAO,CDAE,sBDAqB,CDAC,CDCzC,CDAC,CDAC,CDEK;ADAR,YDAArJ,aDAO,CDAC8I,GDAG,CDAC,mBDAmB,CDAC;ADCf,kBDAe,ADAf,CDAAU,QDAe,EDAA,ADAf,CDAAJ,SDAI,CDACF,QDAQ,EDAE,CDAA;ADAhC,YDAAlJ,aDAO,CDAC8I,GDAG,CDAE,IDAE,ADAH,EDAsB,ADAjB,CDAAU,QDAiB,CDAC;ADClB,kBDAe,ADAf,CDAAC,QDAe,EDAA,ADAf,CDAAH,SDAI,CDACJ,QDAQ,EDAE,CDAA;ADAhC,YDAAlJ,aDAO,CDAC8I,GDAG,CDAE,IDAE,ADAH,EDAsB,ADAjB,CDAAW,QDAiB,CDAC;ADClB,kBDAe,ADAf,CDAAC,QDAe,EDAA,ADAf,CDAAH,SDAI,CDACL,QDAQ,EDAE,CDAA;ADAhC,YDAAlJ,aDAO,CDAC8I,GDAG,CDAE,IDAE,ADAH,EDAsB,ADAjB,CDAAY,QDAiB,CDAC,CDC3B;ADAR,YDAA1J,aDAO,CDAC8I,GDAG,CDAC,EDAE,CDAC,CDEP;ADAR,YDAA9I,aDAO,CDAC8I,GDAG,CDAC,6BDA6B,CDAC,CDElC;ADAR,YDAA9I,aDAO,CDAC8I,GDAG,CDAC,YDAY,CDAC,CDCrB;A,eDAA,aDAQ,CDAA,ADAR,MDAQ,CDAA,ADAR,CDAAa,aDAQ,EDAgC,ADA7B,UDA4B,CDAA,ADAlBX,eDAU,CDAE,CDAAG,UDAK,CDAC,CDACS,GDAG,EDAE;ADCzB,iBDAAjJ,QDAA,CDAA,ADAf,MDAC,ADAD,CDAAkJ,MDAC,CDET;ADFuB;ADCL,sBDAY,ADAZ,CDAAC,QDAY,EDAA,ADAZ,CDAAD,MDAC,CDACX,QDAQ,EDAE,CDAA;ADA7B,gBDAAlJ,aDAO,CDAC8I,GDAG,CDAE,IDAE,ADAH,EDAmB,ADAd,CDAAgB,QDAc,CDAC;ADAA,aDCjC;A,eDFD,eDAcH,aDAQ,CDAE,EDAA,A,IDAA,MDEvB,CDAA,ADFuB,MDEvB,EDAA,ADFuB,CDAAhJ,QDEvB,CDAA,ADFD,CDGQ;ADAR,YDAAX,aDAO,CDAC8I,GDAG,CDAC,EDAE,CDAC,CDEP;ADAR,YDAA9I,aDAO,CDAC8I,GDAG,CDAC,qBDAqB,CDAC,CDC9B;A,eDAA,aDAM,CDAA,ADAN,MDAM,CDAA,ADAN,CDAAiB,WDAM,EDEP,ADFU,UDA4B,CDAA,ADAlBf,eDAU,CDAE,CDAAG,UDAK,CDAC,CDCtCa,KDAK,CDAC,KDAK,CDAE,KDAI,CDAE,KDAI,CDAC,CDCxBJ,GDAG,EDAE;ADCc,iBDAAjJ,QDAA,CDAA,ADAb,MDAC,ADAD,CDAAkJ,MDAC,CDET;ADFqB;ADCH,sBDAY,ADAZ,CDAAI,QDAY,EDAA,ADAZ,CDAAJ,MDAC,CDACX,QDAQ,EDAE,CDAA;ADA7B,gBDAAlJ,aDAO,CDAC8I,GDAG,CDAE,IDAE,ADAH,EDAmB,ADAd,CDAAmB,QDAc,CDAC;ADAA,aDCjC;A,eDFD,eDAcF,WDAM,CDAE,EDAA,A,IDAA,MDErB,CDAA,ADFqB,MDErB,EDAA,ADFqB,CDAApJ,QDErB,CDAA,ADFD,CDGQ;ADAR,YDAAX,aDAO,CDAC8I,GDAG,CDAC,EDAE,CDAC,CDEP;ADAR,YDAA9I,aDAO,CDAC8I,GDAG,CDAC,+CDA+C,CDAC;ADExD,iBDAE,ADAF,CDAAoB,ODAE,EDAG,UDA4B,CDAA,ADAlBlB,eDAU,CDAE,CDAAG,UDAK,CDAC;ADCV,kBDAqB,ADArB,CDAAgB,QDAqB,EDAA,ADArB,CDAAD,ODAE,CDACE,KDAK,EDAE,CDACC,QDAQ,EDAE,CDAA;ADAhD,YDAArK,aDAO,CDAC8I,GDAG,CDAE,cDAY,ADAb,EDAsC,ADAvB,CDAAqB,QDAuB,CDAC;ADE/C,iBDAE,ADAF,CDAAG,ODAE,EDIH,ADJM,UDA4B,CDAA,ADAlBtB,eDAU,CDAE,CDAAG,UDAK,CDAC,CDClCoB,MDAM,CDAC,A,GDAA,MDAe,CDAA,ADAf,kBDAe,CDAA,ADAf,MDAe,EDAA,ADAd,MDAM,CDAE,MDAK,CDAC,CDAC,CDCvBP,KDAK,CDAC,KDAK,CDAE,KDAI,CDAE,KDAI,CDAC,CDCxBQ,ODAO,CDAC,KDAK,CDAE,ODAM,CDAC,CDCtBC,KDAK,CDAC,EDAE,CDAC;ADCe,kBDAqB,ADArB,CDAAC,QDAqB,EDAA,ADArB,CDAAJ,ODAE,CDACF,KDAK,EDAE,CDACC,QDAQ,EDAE,CDAA;ADAhD,YDAArK,aDAO,CDAC8I,GDAG,CDAE,cDAY,ADAb,EDAsC,ADAvB,CDAA4B,QDAuB,CDAC;ADE/C,kBDAK,ADAL,CDAAC,UDAK,EDAG,gCDA+B;ADCvC,iBDAE,ADAF,CDAAC,ODAE,EDCH,ADDM,UDA4B,CDAA,ADAlB5B,eDAU,CDAE,CDAAG,UDAK,CDAC,CDClCa,KDAK,CDAC,MDAM,CDAE,IDAG,CDAE,gCDAK,CDAC;ADCD,kBDAqB,ADArB,CDAAa,QDAqB,EDAA,ADArB,CDAAD,ODAE,CDACR,KDAK,EDAE,CDACC,QDAQ,EDAE,CDAA;ADAhD,YDAArK,aDAO,CDAC8I,GDAG,CDAE,cDAY,ADAb,EDAsC,ADAvB,CDAA+B,QDAuB,CDAC,CDE/C;A,eDAA,mBDAU,CDAA,ADAV,MDAU,CDAA,ADAV,ODAU,CDAA,ADAV,CDAAC,eDAU,EDAG,A,IDAA,MDGf,CDAA,ADHe,YDGf,CDAA,A,GDHuC,MDGxC,CDAA,ADHwC,kBDGxC,CDAA,A,GDHwC,YDGxC,CDAA,ADHwC,MDGxC,CDAA,ADHwC,ODGxC,GDAA,ADFC,GDAA,A,IDAA,YDA4B,CDAA,ADA5B,MDA4B,CDAA,ADA5B,ODA4B,EDAA,ADAnB,MDAM,CDAE,WDAU,CDAC,CDC5B,IDAA,A,IDAA,YDAqB,CDAA,ADArB,MDAqB,CDAA,ADArB,ODAqB,EDAA,ADAZ,KDAK,CDAE,KDAI,CDAC,CDCtB,CDAC;ADCyB,kBDA8C,ADA9C,CDAAC,QDA8C,EDAA,ADA9C,YDAW,CDAC/B,eDAU,CDAE,CDAA8B,eDAU,CDAC,CDACT,QDAQ,EDAE,CDAA;ADAzE,YDAArK,aDAO,CDAC8I,GDAG,CDAE,cDAY,ADAb,EDA+D,ADAhD,CDAAiC,QDAgD,CDAC,CDEpE;ADAR,YDAA/K,aDAO,CDAC8I,GDAG,CDAC,yBDAyB,CDAC;ADAA,SDCvC;AD77BD,uBDKC,A,IDLmB,aDAY,CDAA,ADAZ,MDAY,CDAA,ADA5B,CDAAkC,mBDKH;ADED,uBDKC,A,IDLgB,aDAY,CDAA,ADAZ,MDAY,CDAA,ADAzB,CDAAC,gBDKH;ADMM,qBDAgC,UDAS,ADArC,aDAY,CDAO,MDAM,ADAZ,CDAAC,SDAY,CDYnC;ADZgD,SDAA;ADAV,qBDAS,ADAT,CDAA7K,WDAS;ADAC;ADAA,iBDC/C;A,uBDAA,sBDAAqG,UDAA,EDAe,CDAAsE,mBDAc,ADA7B,CDAA;A,wB,O,G,U;A,wB,O;A,2B,O,G,O;A;A,+B,Q,G,U,C,O;A,wB,O,G,O;ADAS,8BDAE,ADAF,CDAAK,ODAE,EDAA,A,C,QDAA;ADCT,4BDAIA,ODAE,ADAF,GDAU,ADAJ,CDAAH,SDAI;ADAE;ADCP,4BDAA7K,WDAA,EDAwB,ADAxB,cDAwB,CDAA,ADAV,SDAS,CDAC,CDAA;ADA/B,iCDAAM,ODA+B;ADAA;ADChC,qBDAA;A,uBDEH,sBDAA+F,UDAA,EDAe,CDAAuE,gBDAW,ADA1B,CDAA;A,wB,O,G,U;A,wB,O;A,2B,O,G,O;A;A,+B,Q,G,U,C,O;A,wB,O,G,O;ADAS,8BDAE,ADAF,CDAAK,ODAE,EDAA,A,C,QDAA;ADCT,4BDAIA,ODAE,ADAF,GDAU,ADAJ,CDAAJ,SDAI;ADAE;ADCP,4BDAA7K,WDAA,EDAqB,ADArB,cDAqB,CDAA,ADAP,MDAM,CDAC,CDAA;ADA5B,iCDAAM,ODA4B;ADAA;ADC7B,qBDAA;ADEH,oBDAAN,WDAA,EDA2B,ADA3B,cDA2B,CDAA,ADAb,YDAY,CDAC;ADAA,iBDC5B;ADZgD,gBDAAM,ODYhD,CDAA;ADZgD;ADAA;ADYhD;ADAA,kBDAA,ADZsC,CDAAN,WDAA;ADYtC;ADQM,qBDAiC,A,IDAA,QDAQ,ADArC,cDAa,CDAO,MDAM,ADAZ,CDAA6K,SDAY,CDOpC;ADPgD,SDAA;A,eDAT,QDAQ,ADAR,CDAA7K,WDAQ,CDErC;A,eDAA,gBDAAkL,QDAA,CDAA;ADFsC;ADAA;ADC/C,wBDAIL,SDAI,ADAJ,GDAU,ADAF,GDAE;ADAE;ADCP,wBDAAK,QDAA,MDAA,A,IDAA;ADAA,wBDAAlL,WDAA,GDAAkL,QDAA,aDAA;ADAP,6BDAA5K,ODAa;ADAA;ADEX,6BDAS,ADAT,CDAA6K,cDAS,EDAG,aDAY,CDACN,SDAI,CDAC;ADC9B,yBDAK,ADAL,CDAAO,UDAK,EDAG,UDA0B,CDAA,ADAhBD,cDAS,CDAE,CDAAN,SDAI,CDAC;ADCtC,oBDAA7K,WDAA,EDAc,ADAd,CDAAoL,UDAK,CDACC,MDAM,EDAE;ADAA,iBDCf;ADPgD,gBDAA/K,ODOhD,CDAA;ADPgD;ADAA;ADOhD;ADAA,kBDAA,ADPuC,CDAAN,WDAA;ADOvC;ADEM,qBDAiC,A,IDAA,QDAQ,ADArC,cDAa,CDAO,MDAM,ADAZ,CDAAsL,SDAY,CDWpC;ADXgD,SDAA;A,eDAT,QDAQ,ADAR,CDAAtL,WDAQ,CDGrC;A,eDAA,gBDAAuL,QDAA,CDEI;A,eDAA,QDAuB,ADAvB,CDAAC,QDAuB;ADChB,eDAY,ADAZ,CDAAC,QDAY,CDErB;A,eDAA,gBDAAC,QDAA,CDAA;A,eDAA,SDAAC,QDAA,CDAA;ADRoC;ADAA,iBDC3C;A,uBDAA,aDAK,CDAA,ADAL,MDAK,CDAA,ADAL,CDAAC,UDAK,EDAG,A,IDAA,IDAe,CDAA,ADAf,KDAe,CDAA,ADAfN,SDAI,CDAO,IDAG,CDAC;ADC3B,wBDAIM,UDAK,CDAO,KDAA,ADAZ,GDAiB,ADAD,EDAC;ADAE;ADCd,wBDAAL,QDAA,MDAA,A,IDAA;ADAA,wBDAAvL,WDAA,GDAAuL,QDAA,aDAA;ADAP,6BDAAjL,ODAa;ADAA;ADEF,oBDAAkL,QDAA,EDAuB,ADAvB,cDAa,CDACI,UDAK,CDAC,CDAC,CDAC,CDAC,CDAA;A,uBDAhC,QDAM,ADAN,CDAApK,WDAM,EDAG,CDAAgK,QDAuB;ADC3B,uBDAC,ADAD,CDAA/J,MDAC,EDAG,EDAC,CDAA;ADAd;ADA6C,qBDAA;ADAzB,wBDAAgK,QDAA,EDAY,ADAZ,CDAAG,UDAK,CDAO,MDAA;ADAhB,6BDAgB,CDAA,ADAhBnK,MDAC,ADAD,EDAgB,ADAZ,CDAAgK,QDAY,SDC1B;A,2BDAA,QDAI,ADAJ,CDAAZ,SDAI,EDAG,cDAa,CDACe,UDAK,CDACnK,MDAC,CDAC,CDAC;ADCzB,wBDAAiK,QDAA,MDAA,A,IDAA;ADAO,wBDAAA,QDAA,CDAAG,cDAA,CDAArK,WDAM;ADAC,wBDAAkK,QDAA,CDAA/K,UDAA,IDAC;ADAE,wBDAA+K,QDAA,CDAAG,cDAA,CDAAhB,SDAI,EDAA;ADArB,wBDAAc,QDAA,GDAAD,QDAA,aDAA;ADAT,wBDAAlK,WDAM,ADAN,EDAgC,ADAvB,CDAAmK,QDAuB,CDAA;ADFA,wBDAAlK,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA,qBDI3C;ADVsC,oBDAAzB,WDUtC,EDAM,ADAN,CDAAwB,WDAM;ADAA,iBDCP;ADXgD,gBDAAlB,ODWhD,CDAA;ADXgD;ADAA;ADWhD;ADAA,kBDAA,ADXuC,CDAAN,WDAA;ADWvC;ADEM,qBDAqC,A,IDAA,QDAQ,ADAzC,gBDAe,CDAS,MDAM,ADAd,CDAA8L,WDAc,CDWxC;ADXoD,SDAA;A,eDAT,QDAQ,ADAR,CDAA9L,WDAQ,CDGzC;A,eDAA,gBDAA+L,QDAA,CDEI;A,eDAA,QDAuB,ADAvB,CDAAC,QDAuB;ADChB,eDAY,ADAZ,CDAAC,QDAY,CDErB;A,eDAA,gBDAAC,QDAA,CDAA;A,eDAA,SDAAC,QDAA,CDAA;ADRwC;ADAA,iBDC/C;A,uBDAA,aDAK,CDAA,ADAL,MDAK,CDAA,ADAL,CDAAC,UDAK,EDAG,A,IDAA,IDAkB,CDAA,ADAlB,KDAkB,CDAA,ADAlBN,WDAM,CDAO,KDAI,CDAC;ADC9B,wBDAIM,UDAK,CDAO,KDAA,ADAZ,GDAiB,ADAD,EDAC;ADAE;ADCd,wBDAAL,QDAA,MDAA,A,IDAA;ADAA,wBDAA/L,WDAA,GDAA+L,QDAA,aDAA;ADAP,6BDAAzL,ODAa;ADAA;ADEF,oBDAA0L,QDAA,EDAuB,ADAvB,cDAa,CDACI,UDAK,CDAC,CDAC,CDAC,CDAC,CDAA;A,uBDAhC,QDAM,ADAN,CDAA5K,WDAM,EDAG,CDAAwK,QDAuB;ADC3B,uBDAC,ADAD,CDAAvK,MDAC,EDAG,EDAC,CDAA;ADAd;ADA6C,qBDAA;ADAzB,wBDAAwK,QDAA,EDAY,ADAZ,CDAAG,UDAK,CDAO,MDAA;ADAhB,6BDAgB,CDAA,ADAhB3K,MDAC,ADAD,EDAgB,ADAZ,CDAAwK,QDAY,SDC1B;A,2BDAA,QDAI,ADAJ,CDAAX,SDAI,EDAG,cDAa,CDACc,UDAK,CDAC3K,MDAC,CDAC,CDAC;ADCzB,wBDAAyK,QDAA,MDAA,A,IDAA;ADAO,wBDAAA,QDAA,CDAAL,cDAA,CDAArK,WDAM;ADAC,wBDAA0K,QDAA,CDAAvL,UDAA,MDAE;ADAE,wBDAAuL,QDAA,CDAAL,cDAA,CDAAP,SDAI,EDAA;ADAtB,wBDAAa,QDAA,GDAAD,QDAA,aDAA;ADAT,wBDAA1K,WDAM,ADAN,EDAiC,ADAxB,CDAA2K,QDAwB,CDAA;ADFD,wBDAA1K,MDAC,ADAD,EDAS,ADAL,CDAAA,MDAC,ADAD,EDAK,ADAD,EDAC;ADAA,qBDI3C;ADV0C,oBDAAzB,WDU1C,EDAM,ADAN,CDAAwB,WDAM;ADAA,iBDCP;ADXoD,gBDAAlB,ODWpD,CDAA;ADXoD;ADAA;ADWpD;ADAA,kBDAA,ADX2C,CDAAN,WDAA;ADW3C;ADEM,qBDAoC,A,IDAA,QDAQ,ADAxC,eDAc,CDAS,MDAM,ADAd,CDAA8L,WDAc,CDGvC;ADHmD,SDC9C;A,eDAA,QDAW,ADAX,CDAAO,gBDAW,EDAG,gBDAe,CDACP,WDAM,CDAC,CDCzC;A,eDAA,gBDAAQ,QDAA,MDAA,A,IDAA;ADAK,YDAAA,QDAA,CDAA3L,UDAA,kCDA+B;ADAE,YDAA2L,QDAA,CDAAT,cDAA,CDAAQ,gBDAW;ADAC,YDAAC,QDAA,CDAA3L,UDAA,gBDAa,EDAA;ADA/D,mBDAA2L,QDAA;ADAA,SDCD;A;A;ADtHY,YDAA3M,aDAA,EDAA,A,KDAA,sDDAA;AD0CT,YDAAgL,mBDAc,ADAlB,EDKC,A,IDLkC,MDKlC,CDAA,ADLkC,kBDKlC,CDAA,ADLkC,MDKlC,EDAA,ADJC,IDAI,CDAE,ODAM,CDAE,MDAK,CDAE,QDAO,CDAE,KDAI,CDAE,ODAM,CDAE,QDAO,CDAE,WDAU,CDAE,SDAQ,CDCzE,MDAK,CDAE,MDAK,CDAE,QDAO,CDAE,SDAQ,CDAE,SDAQ,CDAE,SDAQ,CDAE,UDAS,CDAE,YDAW,CDC3E,SDAQ,CDAE,MDAK,CDAE,ODAM,CDAE,MDAK,CDAE,MDAK,CDAE,SDAQ,CDAE,UDAS,CDAE,aDAY,CDCxE,ODAM,CDAE,QDAO,CDAE,ODAM,CDAE,SDAQ,CDAE,SDAQ,CDAE,KDAI,CDClD;ADEG,YDAAC,gBDAW,ADAf,EDKC,A,IDL+B,MDK/B,CDAA,ADL+B,kBDK/B,CDAA,ADL+B,MDK/B,EDAA,ADJC,QDAQ,CDAE,MDAK,CDAE,UDAS,CDAE,ODAM,CDAE,MDAK,CDAE,SDAQ,CDAE,ODAM,CDC3D,QDAO,CDAE,SDAQ,CDAE,ODAM,CDAE,QDAO,CDAE,ODAM,CDAE,ODAM,CDAE,ODAM,CDC1D,SDAQ,CDAE,SDAQ,CDAE,QDAO,CDAE,QDAO,CDAE,gBDAe,CDCrD,cDAa,CDAE,aDAY,CDAE,cDAa,CDAE,cDAa,CDC1D;ADAA,SDAA;A;A" }