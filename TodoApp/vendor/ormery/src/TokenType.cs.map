{ "version": 3, "file": "csharp/ormery/src/TokenType.cs", "sources": [ "-work/src/syntax-highlighter.temper.md" ], "sourcesContent": [ "# Temper Syntax Highlighter\n\nA syntax highlighter for Temper code, written in Temper. Uses\nsecure-composition's `html\u0022...\u0022` tagged strings for contextual\nauto-escaping â€” values interpolated into element content are\nHTML-entity-encoded automatically.\n\n    let { html, SafeHtml } = import(\u0022./html\u0022);\n\n## Token Types\n\n    export class TokenType(public name: String) {\n      public get isKeyword(): Boolean { name == \u0022keyword\u0022 }\n      public get isType(): Boolean { name == \u0022type\u0022 }\n      public get isString(): Boolean { name == \u0022string\u0022 }\n      public get isNumber(): Boolean { name == \u0022number\u0022 }\n      public get isComment(): Boolean { name == \u0022comment\u0022 }\n      public get isOperator(): Boolean { name == \u0022operator\u0022 }\n      public get isIdentifier(): Boolean { name == \u0022identifier\u0022 }\n    }\n\n## Token\n\n    export class Token(\n      public tokenType: TokenType,\n      public value: String,\n    ) {\n      public cssClass(): String {\n        let name = tokenType.name;\n        when (name) {\n          \u0022keyword\u0022 -\u003e \u0022kw\u0022;\n          \u0022type\u0022 -\u003e \u0022typ\u0022;\n          \u0022string\u0022 -\u003e \u0022str\u0022;\n          \u0022number\u0022 -\u003e \u0022num\u0022;\n          \u0022comment\u0022 -\u003e \u0022cmt\u0022;\n          \u0022operator\u0022 -\u003e \u0022op\u0022;\n          else -\u003e \u0022id\u0022;\n        }\n      }\n\n      public toHtml(): SafeHtml {\n        let cls = cssClass();\n        html\u0022\u003cspan class='\u0024{cls}'\u003e\u0024{value}\u003c/span\u003e\u0022\n      }\n    }\n\n## Keyword and Type Lists\n\n    let temperKeywords: List\u003cString\u003e = [\n      \u0022if\u0022, \u0022else\u0022, \u0022for\u0022, \u0022while\u0022, \u0022do\u0022, \u0022when\u0022, \u0022break\u0022, \u0022continue\u0022, \u0022return\u0022,\n      \u0022let\u0022, \u0022var\u0022, \u0022class\u0022, \u0022export\u0022, \u0022import\u0022, \u0022public\u0022, \u0022private\u0022, \u0022protected\u0022,\n      \u0022throws\u0022, \u0022new\u0022, \u0022this\u0022, \u0022get\u0022, \u0022set\u0022, \u0022static\u0022, \u0022extends\u0022, \u0022implements\u0022,\n      \u0022true\u0022, \u0022false\u0022, \u0022null\u0022, \u0022bubble\u0022, \u0022orelse\u0022, \u0022of\u0022,\n    ];\n\n    let temperTypes: List\u003cString\u003e = [\n      \u0022String\u0022, \u0022Int\u0022, \u0022Boolean\u0022, \u0022List\u0022, \u0022Map\u0022, \u0022Bubble\u0022, \u0022Pair\u0022,\n      \u0022Float\u0022, \u0022Double\u0022, \u0022Byte\u0022, \u0022Short\u0022, \u0022Long\u0022, \u0022Char\u0022, \u0022Void\u0022,\n      \u0022Record\u0022, \u0022Schema\u0022, \u0022Field\u0022, \u0022Query\u0022, \u0022InMemoryStore\u0022,\n      \u0022ListBuilder\u0022, \u0022MapBuilder\u0022, \u0022WhereClause\u0022, \u0022OrderClause\u0022,\n    ];\n\n## Classifier\n\nClassifies a word token based on known keywords and types.\n\n    export let classifyWord(word: String): TokenType {\n      for (let kw of temperKeywords) {\n        if (kw == word) {\n          return new TokenType(\u0022keyword\u0022);\n        }\n      }\n      for (let tp of temperTypes) {\n        if (tp == word) {\n          return new TokenType(\u0022type\u0022);\n        }\n      }\n      new TokenType(\u0022identifier\u0022)\n    }\n\n## Simple Line Highlighter\n\nSince Temper's String type works with code points and StringIndex rather than\ninteger-indexed substring operations, we use a word-level approach: split each\nline by spaces and classify each token.\n\n    export let highlightWord(word: String): SafeHtml {\n      if (word == \u0022\u0022) {\n        return html\u0022\u0022;\n      }\n      let tokenType = classifyWord(word);\n      let token = new Token(tokenType, word);\n      token.toHtml()\n    }\n\n    export let highlightLine(line: String): SafeHtml {\n      let words = line.split(\u0022 \u0022);\n      if (words.length == 0) {\n        return html\u0022\u0022;\n      }\n      var result = highlightWord(words[0]);\n      for (var i = 1; i \u003c words.length; i = i + 1) {\n        let word = highlightWord(words[i]);\n        result = html\u0022\u0024{result} \u0024{word}\u0022;\n      }\n      result\n    }\n\n    export let highlightSource(source: String): SafeHtml {\n      let lines = source.split(\u0022\\n\u0022);\n      if (lines.length == 0) {\n        return html\u0022\u0022;\n      }\n      var result = highlightLine(lines[0]);\n      for (var i = 1; i \u003c lines.length; i = i + 1) {\n        let line = highlightLine(lines[i]);\n        result = html\u0022\u0024{result}\\n\u0024{line}\u0022;\n      }\n      result\n    }\n\n    export let highlightBlock(source: String): SafeHtml {\n      let highlighted = highlightSource(source);\n      html\u0022\u003cpre class='temper-code'\u003e\u003ccode\u003e\u0024{highlighted}\u003c/code\u003e\u003c/pre\u003e\u0022\n    }\n" ], "names": [ "name" ], "mappings": "AAWiB;AAOgD,CAAA;AAPhD,gBAOgD,AAPhD;AAOgD,KAAA;AAP/B,gBAAY,AAAN,OAAM,AAAZ,CAAAA,SAAY;AACjC,cAA8C,AAA7B,KAAO,AAApB;AAAS,SAAA;AAAb,eAA8C;AAArB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAiB,AAAT,UAAS;AAAA;AAAE;AAC9C,cAAwC,AAA1B,KAAO,AAAjB;AAAM,SAAA;AAAV,eAAwC;AAAlB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAc,AAAN,OAAM;AAAA;AAAE;AACxC,cAA4C,AAA5B,KAAO,AAAnB;AAAQ,SAAA;AAAZ,eAA4C;AAApB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAgB,AAAR,SAAQ;AAAA;AAAE;AAC5C,cAA4C,AAA5B,KAAO,AAAnB;AAAQ,SAAA;AAAZ,eAA4C;AAApB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAgB,AAAR,SAAQ;AAAA;AAAE;AAC5C,cAA8C,AAA7B,KAAO,AAApB;AAAS,SAAA;AAAb,eAA8C;AAArB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAiB,AAAT,UAAS;AAAA;AAAE;AAC9C,cAAgD,AAA9B,KAAO,AAArB;AAAU,SAAA;AAAd,eAAgD;AAAtB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAkB,AAAV,WAAU;AAAA;AAAE;AAChD,cAAoD,AAAhC,KAAO,AAAvB;AAAY,SAAA;AAAhB,eAAoD;AAAxB;AAAE,2BAAI,CAAAA,SAAA,AAAJ,GAAoB,AAAZ,aAAY;AAAA;AAAE,SAAA;AAPjB,yBAAA,AAAR,MAAM,AAAZ,CAAAA,SAAY,CAAE;AAAF,SAAA;AAAZ,iBAAYA,SAAA,AAAZ,EAAY,AAAZ,CAAAA,SAAY;AAAA,SAAE;AAAd;AAAA;AAAA;AAAA;AAAA,4BAAAA,SAAA;AAAA;AAAA;AAAA;AAO+B" }