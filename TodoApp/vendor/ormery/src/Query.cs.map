{ "version": 3, "file": "csharp/ormery/src/Query.cs", "sources": [ "-work/src/ormery.temper.md" ], "sourcesContent": [ "# ORMery - All-in-One Demo\n\nA simplified version of Ecto in Temper, using secure-composition for\ninjection-proof SQL generation.\n\n    let { sql, SqlFragment, SqlBuilder } = import(\u0022./sql\u0022);\n\n## Field and Schema\n\n    export class Field(\n      public name: String,\n      public fieldType: String,\n      public primaryKey: Boolean,\n      public nullable: Boolean,\n    ) {\n      public get description(): String {\n        let pk = if (primaryKey) { \u0022 (PK)\u0022 } else { \u0022\u0022 };\n        let null = if (nullable) { \u0022 (nullable)\u0022 } else { \u0022\u0022 };\n        \u0022\u0024{name}: \u0024{fieldType}\u0024{pk}\u0024{null}\u0022\n      }\n    }\n\n    export class Schema(\n      public tableName: String,\n      public fields: List\u003cField\u003e,\n    ) {\n      public getField(name: String): Field throws Bubble {\n        for (let field of fields) {\n          if (field.name == name) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public hasField(name: String): Boolean {\n        for (let field of fields) {\n          if (field.name == name) {\n            return true;\n          }\n        }\n        false\n      }\n\n      public get primaryKeyField(): Field throws Bubble {\n        for (let field of fields) {\n          if (field.primaryKey) {\n            return field;\n          }\n        }\n        bubble()\n      }\n\n      public get fieldNames(): List\u003cString\u003e {\n        fields.map { (f: Field): String =\u003e f.name }\n      }\n\n      public describe(): String {\n        let header = \u0022Schema: \u0024{tableName}\\n\u0022;\n        let fieldList = fields\n          .map { (f: Field): String =\u003e \u0022  - \u0024{f.description}\u0022 }\n          .join(\u0022\\n\u0022) { (s: String): String =\u003e s };\n        \u0022\u0024{header}\u0024{fieldList}\u0022\n      }\n    }\n\n    export let field(\n      name: String,\n      fieldType: String,\n      primaryKey: Boolean,\n      nullable: Boolean,\n    ): Field {\n      new Field(name, fieldType, primaryKey, nullable)\n    }\n\n### Identifier validation\n\nOnly allow safe SQL identifier characters: `a-z`, `A-Z`, `0-9`, `_`.\nThis closes the table name backdoor where `schema()` accepted arbitrary\nstrings that passed through `safeSql()` → `appendSafe()` unescaped.\n\n    export let isValidIdentifier(name: String): Boolean {\n      if (name.isEmpty) { return false; }\n      for (let c of name) {\n        if (c != char'_') {\n          if (c \u003e= char'a') {\n            if (c \u003e char'z') { return false; }\n          } else if (c \u003e= char'A') {\n            if (c \u003e char'Z') { return false; }\n          } else if (c \u003e= char'0') {\n            if (c \u003e char'9') { return false; }\n          } else {\n            return false;\n          }\n        }\n      }\n      true\n    }\n\n    export let schema(tableName: String, fields: List\u003cField\u003e): Schema {\n      if (!isValidIdentifier(tableName)) { panic(); }\n      let idField = new Field(\u0022id\u0022, \u0022Int\u0022, true, false);\n      let allFields = new ListBuilder\u003cField\u003e();\n      allFields.add(idField);\n      allFields.addAll(fields);\n      new Schema(tableName, allFields.toList())\n    }\n\n## Record and Store\n\n    export class Record(\n      public data: Map\u003cString, String\u003e,\n    ) {\n      public get(field: String): String throws Bubble {\n        data.get(field)\n      }\n\n      public getOr(field: String, fallback: String): String {\n        data.getOr(field, fallback)\n      }\n\n      public has(field: String): Boolean {\n        data.has(field)\n      }\n\n      public get id(): Int throws Bubble {\n        let idStr = data.get(\u0022id\u0022);\n        idStr.toInt32() orelse bubble()\n      }\n\n      public describe(): String {\n        let pairs = data.toListWith { (k: String, v: String): String =\u003e\n          \u0022\u0024{k}: \u0024{v}\u0022\n        };\n        pairs.join(\u0022, \u0022) { (s: String): String =\u003e s }\n      }\n    }\n\n    export class InMemoryStore() {\n      private var tables: MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e;\n      private var nextIds: MapBuilder\u003cString, Int\u003e;\n\n      public constructor() {\n        tables = new MapBuilder\u003cString, ListBuilder\u003cRecord\u003e\u003e();\n        nextIds = new MapBuilder\u003cString, Int\u003e();\n      }\n\n      private ensureTable(tableName: String): Void {\n        if (!tables.has(tableName)) {\n          tables.set(tableName, new ListBuilder\u003cRecord\u003e());\n          nextIds.set(tableName, 1);\n        }\n      }\n\n      public insert(tableName: String, data: Map\u003cString, String\u003e): Record {\n        ensureTable(tableName);\n        let id = nextIds.getOr(tableName, 1);\n        nextIds.set(tableName, id + 1);\n\n        let dataBuilder = data.toMapBuilder();\n        dataBuilder.set(\u0022id\u0022, id.toString());\n        let record = new Record(dataBuilder.toMap());\n\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.add(record);\n        record\n      }\n\n      public all(tableName: String): List\u003cRecord\u003e {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.toList()\n      }\n\n      public get(tableName: String, id: Int): Record throws Bubble {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n\n        for (let record of table.toList()) {\n          let recordId = record.id orelse bubble();\n          if (recordId == id) {\n            return record;\n          }\n        }\n        bubble()\n      }\n\n      public count(tableName: String): Int {\n        ensureTable(tableName);\n        let table = tables.getOr(tableName, new ListBuilder\u003cRecord\u003e());\n        table.length\n      }\n    }\n\n## Query Builder\n\n    export class WhereClause(\n      public field: String,\n      public operator: String,\n      public value: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{operator} \u0024{value}\u0022\n      }\n    }\n\n    export class OrderClause(\n      public field: String,\n      public direction: String,\n    ) {\n      public describe(): String {\n        \u0022\u0024{field} \u0024{direction}\u0022\n      }\n    }\n\n    export class Query(\n      public schema: Schema,\n      public store: InMemoryStore,\n    ) {\n      private var whereClauses: ListBuilder\u003cWhereClause\u003e;\n      private var selectFields: List\u003cString\u003e;\n      private var orderByClauses: ListBuilder\u003cOrderClause\u003e;\n      private var limitValue: Int;\n      private var offsetValue: Int;\n\n      public constructor(schema: Schema, store: InMemoryStore) {\n        this.schema = schema;\n        this.store = store;\n        whereClauses = new ListBuilder\u003cWhereClause\u003e();\n        selectFields = [];\n        orderByClauses = new ListBuilder\u003cOrderClause\u003e();\n        limitValue = -1;\n        offsetValue = 0;\n      }\n\n      public where(field: String, operator: String, value: String): Query {\n        whereClauses.add(new WhereClause(field, operator, value));\n        this\n      }\n\n      public select(fields: List\u003cString\u003e): Query {\n        selectFields = fields;\n        this\n      }\n\n      public orderBy(field: String, direction: String): Query {\n        orderByClauses.add(new OrderClause(field, direction));\n        this\n      }\n\n      public limit(n: Int): Query {\n        limitValue = if (n \u003c 0) { 0 } else { n };\n        this\n      }\n\n      public offset(n: Int): Query {\n        offsetValue = n;\n        this\n      }\n\n      private matchesWhere(record: Record): Boolean {\n        for (let clause of whereClauses.toList()) {\n          let recordValue = record.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            return false;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let matches = when (fieldType) {\n            \u0022Int\u0022 -\u003e compareInt(recordValue, clause.operator, clause.value);\n            \u0022String\u0022 -\u003e compareString(recordValue, clause.operator, clause.value);\n            else -\u003e false;\n          };\n          if (!matches) {\n            return false;\n          }\n        }\n        true\n      }\n\n      private projectRecord(record: Record): Record {\n        if (selectFields.length == 0) {\n          return record;\n        }\n        let builder = new MapBuilder\u003cString, String\u003e();\n        for (let fieldName of selectFields) {\n          let value = record.getOr(fieldName, \u0022\u0022);\n          builder.set(fieldName, value);\n        }\n        new Record(builder.toMap())\n      }\n\n      private compareRecords(a: Record, b: Record, orderClauses: List\u003cOrderClause\u003e): Int {\n        for (let clause of orderClauses) {\n          let aVal = a.getOr(clause.field, \u0022\u0022);\n          let bVal = b.getOr(clause.field, \u0022\u0022);\n          if (!schema.hasField(clause.field)) {\n            continue;\n          }\n          let fieldInfo = schema.getField(clause.field) orelse panic();\n          let fieldType = fieldInfo.fieldType;\n          let cmp = when (fieldType) {\n            \u0022Int\u0022 -\u003e do {\n              let aInt = aVal.toInt32() orelse 0;\n              let bInt = bVal.toInt32() orelse 0;\n              aInt \u003c=\u003e bInt\n            };\n            \u0022String\u0022 -\u003e aVal \u003c=\u003e bVal;\n            else -\u003e 0;\n          };\n          if (cmp != 0) {\n            return if (clause.direction == \u0022desc\u0022) { -cmp } else { cmp };\n          }\n        }\n        0\n      }\n\n      public all(): List\u003cRecord\u003e {\n        let allRecords = store.all(schema.tableName);\n        let filtered = allRecords.filter { (r: Record): Boolean =\u003e\n          matchesWhere(r)\n        };\n        let sorted = if (orderByClauses.length \u003e 0) {\n          let clauses = orderByClauses.toList();\n          filtered.sorted { (a: Record, b: Record): Int =\u003e\n            compareRecords(a, b, clauses)\n          }\n        } else {\n          filtered\n        };\n        let sliced = if (limitValue \u003e= 0) {\n          let start = offsetValue;\n          let end = offsetValue + limitValue;\n          sorted.slice(start, end)\n        } else if (offsetValue \u003e 0) {\n          sorted.slice(offsetValue, sorted.length)\n        } else {\n          sorted\n        };\n        sliced.map { (r: Record): Record =\u003e projectRecord(r) }\n      }\n\n      public toSql(): SqlFragment {\n        toSqlQuery(schema, selectFields, whereClauses.toList(),\n                   orderByClauses.toList(), limitValue, offsetValue)\n      }\n    }\n\n    let compareInt(recordValue: String, operator: String, clauseValue: String): Boolean {\n      let rv = recordValue.toInt32() orelse 0;\n      let cv = clauseValue.toInt32() orelse 0;\n      if (clauseValue != cv.toString()) { return false; }\n      when (operator) {\n        \u0022==\u0022 -\u003e rv == cv;\n        \u0022!=\u0022 -\u003e rv != cv;\n        \u0022\u003e\u0022 -\u003e rv \u003e cv;\n        \u0022\u003c\u0022 -\u003e rv \u003c cv;\n        \u0022\u003e=\u0022 -\u003e rv \u003e= cv;\n        \u0022\u003c=\u0022 -\u003e rv \u003c= cv;\n        else -\u003e false;\n      }\n    }\n\n    let compareString(recordValue: String, operator: String, clauseValue: String): Boolean {\n      when (operator) {\n        \u0022==\u0022 -\u003e recordValue == clauseValue;\n        \u0022!=\u0022 -\u003e recordValue != clauseValue;\n        \u0022\u003e\u0022 -\u003e recordValue \u003e clauseValue;\n        \u0022\u003c\u0022 -\u003e recordValue \u003c clauseValue;\n        \u0022\u003e=\u0022 -\u003e recordValue \u003e= clauseValue;\n        \u0022\u003c=\u0022 -\u003e recordValue \u003c= clauseValue;\n        else -\u003e false;\n      }\n    }\n\n## SQL Generation\n\nPure functions that produce `SqlFragment` from query state using\nsecure-composition's `sql\u0022...\u0022` tagged strings. Interpolated values are\nautomatically escaped by type. Trusted SQL identifiers (table names, column\nnames, operators) are composed via fragment nesting.\n\n### Operator validation\n\nOnly allow known SQL comparison operators. Returns the operator if valid,\nor `=` as a safe fallback.\n\n    let validOperator(op: String): String {\n      when (op) {\n        \u0022=\u0022 -\u003e \u0022=\u0022;\n        \u0022==\u0022 -\u003e \u0022=\u0022;\n        \u0022!=\u0022 -\u003e \u0022!=\u0022;\n        \u0022\u003c\u003e\u0022 -\u003e \u0022\u003c\u003e\u0022;\n        \u0022\u003e\u0022 -\u003e \u0022\u003e\u0022;\n        \u0022\u003c\u0022 -\u003e \u0022\u003c\u0022;\n        \u0022\u003e=\u0022 -\u003e \u0022\u003e=\u0022;\n        \u0022\u003c=\u0022 -\u003e \u0022\u003c=\u0022;\n        else -\u003e \u0022=\u0022;\n      }\n    }\n\n### Trusted identifier fragment\n\nWraps a trusted identifier (table name, column name, operator) as a\n`SqlFragment`. These come from schema definitions, not user input.\n\n    let safeSql(trusted: String): SqlFragment {\n      let b = new SqlBuilder();\n      b.appendSafe(trusted);\n      b.accumulated\n    }\n\n### Column list helper\n\nBuilds the SELECT column list. If no fields specified, returns `*`.\n\n    let columnListSql(selectFields: List\u003cString\u003e): SqlFragment {\n      if (selectFields.length == 0) {\n        sql\u0022*\u0022\n      } else {\n        let first = safeSql(selectFields[0]);\n        var result = sql\u0022\u0024{first}\u0022;\n        for (var i = 1; i \u003c selectFields.length; i = i + 1) {\n          let col = safeSql(selectFields[i]);\n          result = sql\u0022\u0024{result}, \u0024{col}\u0022;\n        }\n        result\n      }\n    }\n\n### WHERE clause helper\n\nBuilds a single WHERE condition. The value is untrusted user input —\n`sql\u0022...\u0022` escapes it by type automatically.\n\n    let whereConditionSql(clause: WhereClause, schema: Schema): SqlFragment {\n      let col = safeSql(clause.field);\n      let op = safeSql(validOperator(clause.operator));\n      let fieldInfo = schema.getField(clause.field) orelse panic();\n      if (fieldInfo.fieldType == \u0022Int\u0022) {\n        let intVal = clause.value.toInt32() orelse 0;\n        if (clause.value != intVal.toString()) {\n          sql\u00221 = 0\u0022\n        } else {\n          sql\u0022\u0024{col} \u0024{op} \u0024{intVal}\u0022\n        }\n      } else {\n        let strVal = clause.value;\n        sql\u0022\u0024{col} \u0024{op} \u0024{strVal}\u0022\n      }\n    }\n\n### ORDER BY clause helper\n\n    let orderBySql(clauses: List\u003cOrderClause\u003e): SqlFragment {\n      let first = safeSql(clauses[0].field);\n      let firstDir = if (clauses[0].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n      var result = sql\u0022\u0024{first}\u0024{firstDir}\u0022;\n      for (var i = 1; i \u003c clauses.length; i = i + 1) {\n        let col = safeSql(clauses[i].field);\n        let dir = if (clauses[i].direction == \u0022desc\u0022) { safeSql(\u0022 DESC\u0022) } else { safeSql(\u0022 ASC\u0022) };\n        result = sql\u0022\u0024{result}, \u0024{col}\u0024{dir}\u0022;\n      }\n      result\n    }\n\n### Full SELECT query builder\n\nAssembles a complete SELECT statement from parts. This is the main pure\nfunction: it takes query state in, returns `SqlFragment` out. Field names\nare validated against the schema — only declared fields pass through\n`safeSql`. Unknown fields are silently dropped, closing the confused deputy\nvector where user-controlled strings could reach `appendSafe`.\n\n    export let toSqlQuery(\n      schema: Schema,\n      selectFields: List\u003cString\u003e,\n      whereClauses: List\u003cWhereClause\u003e,\n      orderClauses: List\u003cOrderClause\u003e,\n      limitValue: Int,\n      offsetValue: Int,\n    ): SqlFragment {\n      let validSelect = selectFields.filter { (f: String): Boolean =\u003e\n        schema.hasField(f)\n      };\n      let validWhere = whereClauses.filter { (c: WhereClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let validOrder = orderClauses.filter { (c: OrderClause): Boolean =\u003e\n        schema.hasField(c.field)\n      };\n      let table = safeSql(schema.tableName);\n      let cols = columnListSql(validSelect);\n      var result = sql\u0022SELECT \u0024{cols} FROM \u0024{table}\u0022;\n      if (validWhere.length \u003e 0) {\n        var conditions = whereConditionSql(validWhere[0], schema);\n        for (var i = 1; i \u003c validWhere.length; i = i + 1) {\n          let next = whereConditionSql(validWhere[i], schema);\n          conditions = sql\u0022\u0024{conditions} AND \u0024{next}\u0022;\n        }\n        result = sql\u0022\u0024{result} WHERE \u0024{conditions}\u0022;\n      }\n      if (validOrder.length \u003e 0) {\n        let ordering = orderBySql(validOrder);\n        result = sql\u0022\u0024{result} ORDER BY \u0024{ordering}\u0022;\n      }\n      if (limitValue \u003e= 0) {\n        result = sql\u0022\u0024{result} LIMIT \u0024{limitValue}\u0022;\n      }\n      if (offsetValue \u003e 0) {\n        result = sql\u0022\u0024{result} OFFSET \u0024{offsetValue}\u0022;\n      }\n      result\n    }\n\n### INSERT statement builder\n\nGenerates an INSERT statement from a schema and a map of field values.\nField names come from the schema (trusted). Values are escaped via\n`sql\u0022...\u0022` by type.\n\n    export let toInsertSql(\n      schema: Schema,\n      values: Map\u003cString, String\u003e,\n    ): SqlFragment {\n      let table = safeSql(schema.tableName);\n      let fieldList = schema.fields.filter { (f: Field): Boolean =\u003e\n        values.has(f.name)\n      };\n      if (fieldList.length == 0) {\n        return sql\u0022\u0022;\n      }\n      let colNames = columnListSql(\n        fieldList.map { (f: Field): String =\u003e f.name }\n      );\n      let firstVal = values.getOr(fieldList[0].name, \u0022\u0022);\n      var vals = if (fieldList[0].fieldType == \u0022Int\u0022) {\n        let iv = firstVal.toInt32() orelse 0;\n        sql\u0022\u0024{iv}\u0022\n      } else {\n        sql\u0022\u0024{firstVal}\u0022\n      };\n      for (var i = 1; i \u003c fieldList.length; i = i + 1) {\n        let val = values.getOr(fieldList[i].name, \u0022\u0022);\n        if (fieldList[i].fieldType == \u0022Int\u0022) {\n          let iv = val.toInt32() orelse 0;\n          vals = sql\u0022\u0024{vals}, \u0024{iv}\u0022;\n        } else {\n          vals = sql\u0022\u0024{vals}, \u0024{val}\u0022;\n        }\n      }\n      sql\u0022INSERT INTO \u0024{table} (\u0024{colNames}) VALUES (\u0024{vals})\u0022\n    }\n\n## SQL Generation Tests\n\n### Basic SELECT\n\n    test(\u0022toSql: select all\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n### SELECT with specific columns\n\n    test(\u0022toSql: select columns\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).select([\u0022name\u0022, \u0022age\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name, age FROM users\u0022);\n    }\n\n### WHERE with string value\n\n    test(\u0022toSql: where string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### WHERE with integer value\n\n    test(\u0022toSql: where int\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18\u0022);\n    }\n\n### SQL injection protection\n\nThe Bobby Tables attack string is safely escaped — single quotes are doubled.\n\n    test(\u0022toSql: SQL injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, bobby);\n      let result = q.toSql().toString();\n      assert(result == \u0022SELECT * FROM users WHERE name = 'Robert''); DROP TABLE users;--'\u0022);\n    }\n\n### Operator normalization\n\nThe `==` operator from the in-memory query API is normalized to SQL `=`.\n\n    test(\u0022toSql: operator normalization\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022==\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Invalid operator fallback\n\nUnknown operators fall back to `=` for safety.\n\n    test(\u0022toSql: invalid operator fallback\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022LIKE\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Alice'\u0022);\n    }\n\n### Multiple WHERE clauses\n\n    test(\u0022toSql: multiple where\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .where(\u0022age\u0022, \u0022\u003c\u0022, \u002230\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE age \u003e= 18 AND age \u003c 30\u0022);\n    }\n\n### ORDER BY\n\n    test(\u0022toSql: order by\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022name\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY name ASC\u0022);\n    }\n\n### ORDER BY descending\n\n    test(\u0022toSql: order by desc\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).orderBy(\u0022age\u0022, \u0022desc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users ORDER BY age DESC\u0022);\n    }\n\n### LIMIT and OFFSET\n\n    test(\u0022toSql: limit\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(10);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 10\u0022);\n    }\n\n    test(\u0022toSql: offset\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).offset(5);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users OFFSET 5\u0022);\n    }\n\n### Complex query\n\n    test(\u0022toSql: complex query\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10)\n        .offset(20);\n      assert(q.toSql().toString() ==\n        \u0022SELECT name, age FROM users WHERE age \u003e= 18 ORDER BY age DESC LIMIT 10 OFFSET 20\u0022);\n    }\n\n### Unicode in values\n\n    test(\u0022toSql: unicode escaping\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022Hello 世界\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'Hello 世界'\u0022);\n    }\n\n### Embedded quotes in values\n\n    test(\u0022toSql: embedded quotes\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022O'Brien\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = 'O''Brien'\u0022);\n    }\n\n### Empty string value\n\n    test(\u0022toSql: empty string\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022name\u0022, \u0022=\u0022, \u0022\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE name = ''\u0022);\n    }\n\n### INSERT statement\n\n    test(\u0022toInsertSql: basic insert\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022INSERT INTO users (name, age) VALUES ('Alice', 25)\u0022);\n    }\n\n### INSERT with injection protection\n\n    test(\u0022toInsertSql: injection blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Robert'); DROP TABLE users;--\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() ==\n        \u0022INSERT INTO users (name) VALUES ('Robert''); DROP TABLE users;--')\u0022);\n    }\n\n### toSqlQuery as standalone pure function\n\n    test(\u0022toSqlQuery: standalone\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let result = toSqlQuery(\n        s, [\u0022name\u0022], [new WhereClause(\u0022age\u0022, \u0022\u003e\u0022, \u002221\u0022)],\n        [new OrderClause(\u0022name\u0022, \u0022asc\u0022)], 5, 0,\n      );\n      assert(result.toString() ==\n        \u0022SELECT name FROM users WHERE age \u003e 21 ORDER BY name ASC LIMIT 5\u0022);\n    }\n\n### Adversarial field name protection\n\nField names not in the schema are silently dropped from SQL generation.\nThis prevents confused deputy attacks where user-controlled strings\ncould reach `appendSafe` through field name positions.\n\n    test(\u0022toSql: adversarial field name blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .where(\u00221=1; DROP TABLE users; --\u0022, \u0022=\u0022, \u0022Alice\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial select column blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .select([\u0022name\u0022, \u00221; DROP TABLE users\u0022]);\n      assert(q.toSql().toString() == \u0022SELECT name FROM users\u0022);\n    }\n\n    test(\u0022toSql: adversarial order by blocked\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store)\n        .orderBy(\u00221; DROP TABLE users\u0022, \u0022asc\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users\u0022);\n    }\n\n## Security Audit Fix Tests\n\n### Fix #1: Table name validation\n\n    test(\u0022isValidIdentifier: valid names\u0022) {\n      assert(isValidIdentifier(\u0022users\u0022));\n      assert(isValidIdentifier(\u0022user_table\u0022));\n      assert(isValidIdentifier(\u0022Table1\u0022));\n      assert(isValidIdentifier(\u0022_private\u0022));\n      assert(isValidIdentifier(\u0022a\u0022));\n    }\n\n    test(\u0022isValidIdentifier: invalid names\u0022) {\n      assert(!isValidIdentifier(\u0022\u0022));\n      assert(!isValidIdentifier(\u0022users; DROP TABLE\u0022));\n      assert(!isValidIdentifier(\u0022users--\u0022));\n      assert(!isValidIdentifier(\u0022ta ble\u0022));\n      assert(!isValidIdentifier(\u0022table.name\u0022));\n      assert(!isValidIdentifier(\u0022Robert'); DROP TABLE users;--\u0022));\n    }\n\n### Fix #3: Non-numeric value for Int field\n\n    test(\u0022toSql: non-numeric Int value produces always-false\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users WHERE 1 = 0\u0022);\n    }\n\n    test(\u0022in-memory: non-numeric Int value matches nothing\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u00220\u0022),\n      ]));\n      let results = new Query(s, store).where(\u0022age\u0022, \u0022=\u0022, \u0022admin\u0022).all();\n      assert(results.length == 0);\n    }\n\n### Fix #5: LIMIT zero and negative\n\n    test(\u0022toSql: limit zero emits LIMIT 0\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      let q = new Query(s, store).limit(0);\n      assert(q.toSql().toString() == \u0022SELECT * FROM users LIMIT 0\u0022);\n    }\n\n    test(\u0022in-memory: limit zero returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(0).all();\n      assert(results.length == 0);\n    }\n\n    test(\u0022in-memory: negative limit clamped to zero\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let store = new InMemoryStore();\n      store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n      ]));\n      let results = new Query(s, store).limit(-5).all();\n      assert(results.length == 0);\n    }\n\n### Fix #6: Empty insert safety\n\n    test(\u0022toInsertSql: no matching fields returns empty\u0022) {\n      let s = schema(\u0022users\u0022, [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n      ]);\n      let vals = new Map\u003cString, String\u003e([\n        new Pair(\u0022nonexistent\u0022, \u0022value\u0022),\n      ]);\n      let result = toInsertSql(s, vals);\n      assert(result.toString() == \u0022\u0022);\n    }\n\n## Demo\n\n    export let main(): Void {\n      console.log(\u0022=== ORMery Demo ===\\n\u0022);\n\n      let userFields = [\n        field(\u0022name\u0022, \u0022String\u0022, false, false),\n        field(\u0022age\u0022, \u0022Int\u0022, false, false),\n        field(\u0022email\u0022, \u0022String\u0022, false, true),\n      ];\n      let userSchema = schema(\u0022users\u0022, userFields);\n\n      console.log(userSchema.describe());\n      console.log(\u0022\u0022);\n\n      let store = new InMemoryStore();\n\n      let rec1 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Alice\u0022),\n        new Pair(\u0022age\u0022, \u002225\u0022),\n        new Pair(\u0022email\u0022, \u0022alice@example.com\u0022),\n      ]));\n\n      let rec2 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Bob\u0022),\n        new Pair(\u0022age\u0022, \u002230\u0022),\n        new Pair(\u0022email\u0022, \u0022bob@example.com\u0022),\n      ]));\n\n      let rec3 = store.insert(\u0022users\u0022, new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022Charlie\u0022),\n        new Pair(\u0022age\u0022, \u002217\u0022),\n        new Pair(\u0022email\u0022, \u0022charlie@example.com\u0022),\n      ]));\n\n      console.log(\u0022Inserted 3 users:\u0022);\n      console.log(\u0022  \u0024{rec1.describe()}\u0022);\n      console.log(\u0022  \u0024{rec2.describe()}\u0022);\n      console.log(\u0022  \u0024{rec3.describe()}\u0022);\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== In-Memory Queries ===\\n\u0022);\n\n      console.log(\u0022All users:\u0022);\n      let allUsers = new Query(userSchema, store).all();\n      for (let u of allUsers) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022Adults (age \u003e= 18):\u0022);\n      let adults = new Query(userSchema, store)\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .all();\n      for (let u of adults) {\n        console.log(\u0022  \u0024{u.describe()}\u0022);\n      }\n      console.log(\u0022\u0022);\n\n      console.log(\u0022=== SQL Generation (secure-composition) ===\\n\u0022);\n\n      let q1 = new Query(userSchema, store);\n      console.log(\u0022SELECT all: \u0024{q1.toSql().toString()}\u0022);\n\n      let q2 = new Query(userSchema, store)\n        .select([\u0022name\u0022, \u0022age\u0022])\n        .where(\u0022age\u0022, \u0022\u003e=\u0022, \u002218\u0022)\n        .orderBy(\u0022age\u0022, \u0022desc\u0022)\n        .limit(10);\n      console.log(\u0022Complex:    \u0024{q2.toSql().toString()}\u0022);\n\n      let bobby = \u0022Robert'); DROP TABLE users;--\u0022;\n      let q3 = new Query(userSchema, store)\n        .where(\u0022name\u0022, \u0022=\u0022, bobby);\n      console.log(\u0022Injection:  \u0024{q3.toSql().toString()}\u0022);\n\n      let insertVals = new Map\u003cString, String\u003e([\n        new Pair(\u0022name\u0022, \u0022O'Malley\u0022),\n        new Pair(\u0022age\u0022, \u002242\u0022),\n      ]);\n      console.log(\u0022INSERT:     \u0024{toInsertSql(userSchema, insertVals).toString()}\u0022);\n\n      console.log(\u0022\\n=== Demo Complete ===\u0022);\n    }\n" ], "names": [ "schema", "store", "whereClauses", "selectFields", "orderByClauses", "limitValue", "offsetValue", "t#3898", "t#2220", "t#3899", "where", "field", "operator", "value", "t#3896", "select", "fields", "orderBy", "direction", "t#3894", "limit", "n", "t#2209", "offset", "matchesWhere", "record", "return", "t#3883", "t#3885", "t#3887", "t#3889", "t#3890", "t#3891", "t#3892", "t#3893", "this", "i", "el", "clause", "recordValue", "getOr", "hasField", "fn", "t#2198", "getField", "fieldInfo", "fieldType", "matches", "compareInt", "compareString", "projectRecord", "t#3878", "builder", "fieldName", "compareRecords", "a", "b", "orderClauses", "t#3862", "t#3864", "t#3866", "t#3868", "t#2177", "t#2179", "aVal", "bVal", "t#2174", "cmp", "aInt", "bInt", "all", "t#3853", "t#3854", "t#3855", "t#3856", "t#3857", "t#3846", "allRecords", "r", "filtered", "sorted", "clauses", "sliced", "start", "end", "toSql" ], "mappings": "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" }