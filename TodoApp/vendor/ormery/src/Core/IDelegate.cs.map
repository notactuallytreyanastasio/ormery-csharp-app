{ "version": 3, "file": "csharp/ormery/src/Core/IDelegate.cs", "sources": [ "-work/src/core/contextual-autoescaping.temper.md" ], "sourcesContent": [ "# Contextual Autoescaping Framework\n\nThis defines a framework for building contextual autoescaping\naccumulators that can be highly statically optimized because the\nseparate steps, listed below, are all pure functional operators that\ncan be inlined and simplified at compile time.\n\nContext encapsulates a state in a streaming parser.  It's used both to\nparse the fixed part of the content, and to pick escapers to preserve\nthe meaning of subsequent fixed parts.\n\n    export interface Context {\n      public toString(): String;\n    }\n\nAutoesc bundles together a context and a subsidiary automaton.\n\n    export class AutoescState\u003cCONTEXT extends Context\u003e(\n      public context: CONTEXT,\n      public subsidiary: Subsidiary?,\n    ) {}\n\nAfterPropagate bundles up information about propagating context across a fixed part,\nand context transitions needed to move into a state where an interpolation is valid.\n\n    export class AfterPropagate\u003cCONTEXT extends Context\u003e(\n      public adjustedString: String,\n      public consumed: StringIndex,\n      public stateAfter: AutoescState\u003cCONTEXT\u003e,\n    ) {\n\npush specifies a delegate for a nested language.\nThe *Codec* is used to decode content before feeding it to the delegate, and to\nreencode the delegate's adjusted output.\n\n      public push(delegate: Delegate, codec: Codec): AfterPropagate\u003cCONTEXT\u003e {\n        new AfterPropagate\u003cCONTEXT\u003e(\n          adjustedString,\n          consumed,\n          new AutoescState\u003cCONTEXT\u003e(stateAfter.context, new Subsidiary(delegate, codec)),\n        )\n      }\n\npop undoes a push by removing a previously pushed delegate when a\nnested language region ends.\n\n      public pop(): AfterPropagate\u003cCONTEXT\u003e {\n        new AfterPropagate\u003cCONTEXT\u003e(\n          adjustedString,\n          consumed,\n          new AutoescState\u003cCONTEXT\u003e(stateAfter.context, null),\n        )\n      }\n\nfeed gives a nested language delegate the adjustedString, so that it\ncan reconsider it in the context of the nested language.  This may\ninvolve applying a codec to decode the content before the nested\nlanguage delegate handles it, and then re-encoding if there are any\nadjustements made by the delegate.\n\n      public feed(prepareForInterp: Boolean): AfterPropagate\u003cCONTEXT\u003e {\n        let subsidiary = stateAfter.subsidiary;\n        if (subsidiary != null) {\n          let adjustedFromDelegate = feedSubsidiary(subsidiary, adjustedString, prepareForInterp);\n          new AfterPropagate\u003cCONTEXT\u003e(adjustedFromDelegate, consumed, stateAfter)\n        } else {\n          this\n        }\n      }\n    }\n\nContextPropagator knows how to consumes a chunk of context from a literalPart and transition\nto the Context after it.\n\n    export interface ContextPropagator\u003cCONTEXT extends Context\u003e {\n\nafter computes the context after processing the literalPart and any\nadjustments made to the literal part.\n\nIf literalPart is null, then we're doing a context transition to get\ninto a state where we're ready to interpolate an untrusted value.\n\n      after(\n        before: AutoescState\u003cCONTEXT\u003e,\n        literalPart: String?,\n      ): AfterPropagate\u003cCONTEXT\u003e;\n    }\n\nDelegate can represent an automaton for a nested language that can propagates its own state over\nstrings that relate to chunks of content from the outer language.  The content can be\ndecoded via a *Codec*.\n\n    export interface Delegate {\n      process(fixed: String?): String;\n    }\n\nContextDelegate makes clear that a delegate uses the Context and AutoescState mechanism for parsing.\n\n    export interface ContextDelegate\u003cCONTEXT extends Context\u003e extends Delegate {\n      protected get state(): AutoescState\u003cCONTEXT\u003e;\n      protected set state(x: AutoescState\u003cCONTEXT\u003e): Void;\n      protected get contextPropagator(): ContextPropagator\u003cCONTEXT\u003e;\n\n      process(known: String?): String {\n        let after = propagateOver\u003cCONTEXT\u003e(contextPropagator, this.state, known);\n        this.state = after.stateAfter;\n        after.adjustedString\n      }\n    }\n\nEscaper is for transforms from untrusted values to trustworthy values.\n\nThey should be stateless, only useful for their behaviour, unless they\nrepresent the composition of two more escapers in which case they should\nhave two properties: `first` and `second` indicating the application order.\n\n    export interface Escaper {\n      // One or more apply methods like\n      // apply(interpolation: String): OUT;\n    }\n\n(*OUT* is the representation of the trustworthy output and must be\naccepted by with the collector type's *append* method.)\n\npropagateOver is used by both the accumulators and context delegates to propagate context over\na known safe chunk.  Propagation is usual defined in terms of transition tables, and each\ntransition consumes some prefix of the remaining content, so this does enough transitions to\nprocess the entire chunk.\n\n    export let propagateOver\u003cCONTEXT extends Context\u003e(\n      contextPropagator: ContextPropagator\u003cCONTEXT\u003e,\n      before: AutoescState\u003cCONTEXT\u003e,\n      known: String?\n    ): AfterPropagate\u003cCONTEXT\u003e {\n      if (known == null) {\n        contextPropagator.after(before, null)\n      } else {\n        var state = before;\n        var remainder = known;\n        let adjusted = new StringBuilder();\n        while (!remainder.isEmpty) {\n          let after = contextPropagator.after(state, remainder);\n          adjusted.append(after.adjustedString);\n          state = after.stateAfter;\n          remainder = remainder.slice(after.consumed, remainder.end);\n        }\n        new AfterPropagate(adjusted.toString(), known.end, state)\n      }\n    }\n\nEscaperPicker returns the escaper that needs to be applied to untrusted parts to render them\nsafe in context.\n\n    export interface EscaperPicker\u003cCONTEXT extends Context, ESC extends Escaper\u003e {\n      escaperFor(before: AutoescState\u003cCONTEXT\u003e): ESC;\n    }\n\nCONTEXT is a type for context values that track the parser context of\nthe accumulated prefix.  ESC is the type used to represent escapers\nthat convert interpolated expression values to PARTS.\n\nAdditionally, there are two names below that are mentioned in static\nconventions but which need not be represented as type parameters.\nCOLLECTOR is a mutable type that collects safe and unsafe parts and\nwhich is used to produce the output.  OUT is the type of the final\naccumulated value.\n\n    export interface ContextualAutoescapingAccumulator\u003cCONTEXT extends Context, ESC extends Escaper\u003e {\n      // By convention, these are defined in concrete accumulator types.\n      // public static initialState(): AutoescState\u003cCONTEXT\u003e { ... }\n      // public static newCollector(): COLLECTOR { ... }\n      // public static propagator(): ContextPropagator\u003cCONTEXT\u003e { ... }\n      // public static picker(): EscaperPicker\u003cCONTEXT, PART, ESC\u003e { ... }\n      // public static fromCollector(collector: COLLECTOR): OUT;\n      // public static mergeStates(a: AutoescState\u003cCONTEXT\u003e, b: AutoescState\u003cCONTEXT\u003e): AutoescState\u003cCONTEXT\u003e;\n      // - state is initialized to initialState()\n      // - The internal collector property is initialized to newCollector()\n      // - contextPropagator() just returns propagator().\n      // - escaperPicker() just returns picker().\n      // - get accumulated() just returns fromCollector(collector)\n\n      protected get state(): AutoescState\u003cCONTEXT\u003e;\n      protected set state(newState: AutoescState\u003cCONTEXT\u003e): Void;\n\n      public get escaperPicker(): EscaperPicker\u003cCONTEXT, ESC\u003e;\n      public get contextPropagator(): ContextPropagator\u003cCONTEXT\u003e;\n\n      public prepareForAppend(): ESC {\n        if (DEBUG) {\n          console.log(\u0022prepare, before: \u0024{context.toString()}\u0022);\n        }\n        let after = propagateOver\u003cCONTEXT\u003e(contextPropagator, this.state, null);\n        this.state = after.stateAfter;\n        let adjusted = after.adjustedString;\n        if (!adjusted.isEmpty) {\n          collectFixed(adjusted);\n        }\n        if (DEBUG) {\n          console.log(\u0022-\u003e \u0024{context.toString()}\u0022);\n        }\n        escaperPicker.escaperFor(this.state)\n      }\n\n      // Need one or more append methods\n\n      public appendSafe(known: String): Void {\n        if (DEBUG) {\n          console.log(\u0022appendSafe: `\u0024{known}`, before: \u0024{context}\u0022);\n        }\n        let after = propagateOver\u003cCONTEXT\u003e(contextPropagator, this.state, known);\n        this.state = after.stateAfter;\n        let adjusted = after.adjustedString;\n        if (!adjusted.isEmpty) {\n          collectFixed(adjusted);\n        }\n        if (DEBUG) {\n          console.log(\u0022-\u003e \u0024{context}\u0022);\n        }\n      }\n\n      /** Appends the fixed, trusted fragment to the collector. */\n      protected collectFixed(fixedFragment: String): Void;\n    }\n\nfeed allows a subsidiary language handler a chance to update its own\ncontext and perhaps offer its own adjustments.\n\nFor example, an HTML state machine might use a subsidiary CSS state\nmachine to process the body of a `\u003cstyle\u003e` element, but still retain\ncontrol over identifying the `\u003c/style\u003e` end tag which ends the\nelement.\n\n    let feedSubsidiary(\n      subsidiary: Subsidiary,\n      adjustedStr: String,\n      prepareForInterp: Boolean,\n    ): String {\n      var str = adjustedStr;\n\n      let delegate = subsidiary.delegate;\n      let codec = subsidiary.codec;\n\n      str = codec.decode(str);\n\n      str = delegate.process(str);\n      if (prepareForInterp) {\n        str = \u0022\u0024{str}\u0024{delegate.process(null)}\u0022;\n      }\n\n      if (codec != null) {\n        str = codec.encode(str);\n      }\n\n      str\n    }\n\nCodecs allow encoding and decoding a string according to some escaping\nconvention.\nSometimes we need to decode strings before passing to a subsidiary state\nmachine and re-encode any strings that they adjust.\n\n    export interface Codec {\n      encode(s: String): String;\n      decode(s: String): String;\n    }\n\n    export class Subsidiary(\n      public delegate: Delegate,\n      public codec: Codec,\n    ) {}\n\n    let DEBUG = false;\n" ], "names": [ "process", "fixed" ], "mappings": "AA4FqB,gBACgB,CAAA,AADhB;AACgB,CAAA;AADhB,oBACgB,AADhB;AACgB,KAAA;AAAN,cAAM,AAA/B,CAAAA,OAAO,CAAQ,MAAO,EAAA,AAAd,CAAAC,UAAc,CAAS;AAAA;AAAA" }